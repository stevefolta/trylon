trylon Objects

extend Compiler CompiledProto
	emit-code
		status-reporter = compiler status-reporter
		status-reporter report: "Generating code for " + name + "..."
		status-reporter indent

		if compiler build-settings is-verbose
			status-reporter report: name + " has these functions:"
			status-reporter indent
			for name in functions keys
				status-reporter report: name
			status-reporter unindent
		
		is-changed = emit-jolt-file

		status-reporter unindent

		is-changed = true
		return is-changed


	emit-jolt-file
		status-reporter = compiler status-reporter
		iff debug-emission
			status-reporter report: "Emitting " + name + "..."
			status-reporter indent

		# Open the file.
		file = 	--
			File new: 	--
				compiler build-settings jolt-sources-dir + "/" + full-name + ".k"
		stream = ExistingFileStream new: file

		# Define the proto.
		# ...but not for Trylid or Standard Object (which are created specially in
		# (setup-Trylid)).
		if parent && superclass
			parent-access = parent access
			superclass-access = superclass access
			slots = Expression new: fields count
			index = 0
			for field in fields
				slots at: index put: field name intern
				index += 1
			expr = 	--
				Expression 	--
					with: 'define-trylid-proto' 	--
					with: name intern 	--
					with: parent-access 	--
					with: superclass-access 	--
					with: slots
			expr emit: stream
			stream write-line
			stream write-line

		# Add loaders for the subprotos.
		got-one = false
		for function in functions values
			if function is-a: ProtoFunction
				compiled-code = function emit-code
				if compiled-code
					compiled-code emit: stream
					stream write-line
					got-one = true
		if got-one
			stream write-line

		# Add '.used-contexts'.
		if !(uses-protos is-empty)
			tuple-expr = Expression new: uses-protos count + 1
			tuple-expr at: 0 put: 'trylid-tuple'
			index = 1
			for proto in uses-protos
				tuple-expr at: index put: proto access
				index += 1
			expr = 	--
				Expression 	--
					with: 'add-constant-field' 	--
					with: '.used-contexts' 	--
					with: access 	--
					with: tuple-expr
			expr emit: stream
			stream write-line
			stream write-line

		# Compile all the functions.
		for function in functions values
			if function is-a: ProtoFunction
				continue
			iff debug-function-emission
				status-reporter report: "Emitting " + function name + "..."
				status-reporter indent
			compiled-code = function emit-code
			if compiled-code
				compiled-code emit: stream
				stream write-line
				iff hacky-backtrace
					stream write-line: "(name-last-lambda \"" + function name + "\")"
				stream write-line
			iff debug-function-emission
				status-reporter unindent
		
		iff debug-loading
			stream write-line: "(say \"; " + name + " loaded.\")"

		stream close
		iff debug-emission
			status-reporter unindent


	iff targeting-jolt
		translate: compiler
			# Make sure there's a superclass.
			if superclass == nil
				superclass = ExistingProto new: "Object" proto: Object

			# Start creating the big expression that creates the proto and all its
			# components.
			stream = Pepsi WriteStream on: (Expression new: functions count + 1)
			stream nextPut: 'begin'

			# Define the proto.
			slots = Expression new: fields count
			index = 0
			for field in fields
				slots at: index put: field name intern
				index += 1
			expr = 	--
				Expression 	--
					with: 'define-trylid-proto' 	--
					with: name intern 	--
					with: parent access 	--
					with: superclass access 	--
					with: slots
			stream nextPut: expr

			# ... We may need to add loaders for any subprotos, to deal with
			# dependencies.

			# Add the functions.
			for function in functions values
				if function is-translatable
					function prepare-to-emit
					stream nextPut: function

			return compiler translateExpression: stream contents


	access
		if is-main
			return 'Trylid'
		else if is-root-object
			return 'trylid-root-object'
		else
			iff not-anymore
				return 	--
					Expression 	--
						with: 'send' 	--
						with: (Expression with: 'quote' with: name intern) 	--
						with: parent access
			list = List new
			namespace = this
			while !namespace is-main
				list push-front: namespace
				namespace = namespace parent
			expr = Expression new: list count + 1
			expr at: 0 put: 'trylid-proto'
			index = 1
			for namespace in list
				expr at: index put: namespace name intern
				index += 1
			return expr



# Copyright 2007 Steve Folta.  See the License file.

