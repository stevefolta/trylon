trylon Functions

extend Compiler TrylonFunction
	emit-call: arguments
		virtual

	translate-call: arguments compiler: compiler
		# Default: use emit-call.
		return (emit-call: arguments) translate: compiler

	emit-code
		# Default: nothing to do.
		return nil

	is-translatable
		return false



##### Object structure.

extend Compiler CompiledFunction
	emit-call: arguments
		expr = Expression new: arguments count + 3
		expr at: 0 put: 'send'
		expr at: 1 put: (Expression with: 'quote' with: name intern)
		expr at: 2 put: on-proto access
		index = 3
		for arg in arguments
			expr at: index put: arg jolt-expression
			index += 1
		return expr

	translate-call: arguments compiler: compiler
		expr = Expression new: arguments count + 3
		expr at: 0 put: 'send'
		expr at: 1 put: (Expression with: 'quote' with: name intern)
		expr at: 2 put: on-proto access
		index = 3
		for arg in arguments
			expr at: index put: arg
			index += 1
		return compiler translateExpression: expr

	emit-code
		if body == nil
			return
		
		expr = Expression new: arguments count + 4
		expr at: 0 put: 'define-send'
		expr at: 1 put: (Expression with: 'quote' with: name intern)
		expr at: 2 put: on-proto access
		index = 3
		for arg in arguments
			expr at: index put: arg name intern
			index += 1
		expr at: index put: body jolt-expression
		return expr

	translate: compiler
		expr = Expression new: arguments count + 4
		expr at: 0 put: 'define-send'
		expr at: 1 put: (Expression with: 'quote' with: name intern)
		expr at: 2 put: on-proto access
		index = 3
		for arg in arguments
			expr at: index put: arg name intern
			index += 1
		expr at: index put: body
		return compiler translateExpression: expr

	is-translatable
		return true


extend Compiler NewFunction
	emit-call: arguments
		allocation = 	--
			Expression 	--
				with: 'send' 	--
				with: (Expression with: 'quote' with: 'clone') 	--
				with: on-proto access
		creator-call = Expression new: arguments count + 3
		creator-call at: 0 put: 'send'
		creator-call at: 1 put: (Expression with: 'quote' with: creator name intern)
		creator-call at: 2 put: 'new-object'
		index = 3
		for arg in arguments
			creator-call at: index put: arg jolt-expression
			index += 1
		let-spec = Expression with: (Expression with: 'new-object' with: allocation)
		return 	--
			Expression with: 'let' with: let-spec with: creator-call with: 'new-object'

	translate-call: arguments compiler: compiler
		(Send new: name object: on-proto access arguments: arguments) 	--
			translate: compiler

	emit-code
		allocation = 	--
			Expression 	--
				with: 'send' 	--
				with: (Expression with: 'quote' with: 'raw-new') 	--
				with: on-proto access
		creator-call = Expression new: creator arguments count + 3
		creator-call at: 0 put: 'send'
		creator-call at: 1 put: (Expression with: 'quote' with: creator name intern)
		creator-call at: 2 put: 'new-object'
		index = 3
		for arg in creator arguments
			creator-call at: index put: arg name intern
			index += 1
		let-spec = Expression with: (Expression with: 'new-object' with: allocation)
		body = 	--
			Expression with: 'let' with: let-spec with: creator-call with: 'new-object'
		
		expr = Expression new: creator arguments count + 4
		expr at: 0 put: 'define-send'
		expr at: 1 put: (Expression with: 'quote' with: name intern)
		expr at: 2 put: on-proto access
		index = 3
		for arg in creator arguments
			expr at: index put: arg name intern
			index += 1
		expr at: index put: body
		return expr

	translate: compiler
		return compiler translateExpression: emit-code
	is-translatable
		return true


extend Compiler PrimitiveFunction
	emit-call: arguments
		expr = Expression new: arguments count + 3
		expr at: 0 put: 'send'
		expr at: 1 put: (Expression with: 'quote' with: name intern)
		expr at: 2 put: on-proto access
		index = 3
		for arg in arguments
			expr at: index put: arg jolt-expression
			index += 1
		return expr

	translate-call: arguments compiler: compiler
		expr = Expression new: arguments count + 3
		expr at: 0 put: 'send'
		expr at: 1 put: (Expression with: 'quote' with: name intern)
		expr at: 2 put: on-proto access
		index = 3
		for arg in arguments
			expr at: index put: arg
			index += 1
		return compiler translateExpression: expr


extend Compiler ProtoFunction
	emit-call: arguments
		return proto access

	emit-code
		if proto is-main
			return nil
		list = List new
		namespace = proto
		while !namespace is-main
			list push-front: namespace
			namespace = namespace parent
		expr = Expression new: list count + 1
		expr at: 0 put: 'install-proto-loader'
		index = 1
		for namespace in list
			expr at: index put: namespace name intern
			index += 1
		return expr


extend Compiler FieldGetter
	emit-call: arguments
		# Could do this more efficiently...
		return 	--
			Expression 	--
				with: 'send' 	--
				with: (Expression with: 'quote' with: field name intern) 	--
				with: on-proto access


extend Compiler FieldSetter
	emit-call: arguments
		# Could do this more efficiently...
		return 	--
			Expression 	--
				with: 'send' 	--
				with: (Expression with: 'quote' with: (field name + ":") intern) 	--
				with: on-proto access 	--
				with: arguments first-item jolt-expression

	translate-call: arguments compiler: compiler
		# Could do this more efficiently...
		expr = 	--
			Expression 	--
				with: 'send' 	--
				with: (Expression with: 'quote' with: (field name + ":") intern) 	--
				with: on-proto access 	--
				with: arguments first-item
		return compiler translateExpression: expr


extend Compiler SharedFieldGetter
	emit-call: arguments
		return 	--
			Expression 	--
				with: 'send' 	--
				with: (Expression with: 'quote' with: field name intern) 	--
				with: on-proto access

	emit-code
		# If it has an intial value, emit the literal.
		initial-value = nil
		if field initial-value
			initial-value = field initial-value jolt-expression
		else
			initial-value = 'nil'
		
		# Just emit the declaration.
		return 	--
			Expression 	--
				with: 'add-shared-field' 	--
				with: field name intern 	--
				with: on-proto access 	--
				with: initial-value


	translate: compiler
		# Handle the initial value.
		initial-value = field initial-value
		if initial-value == nil
			initial-value = 'nil'
		
		# Translate.
		expr = 	--
			Expression 	--
				with: 'add-shared-field' 	--
				with: field name intern 	--
				with: on-proto access 	--
				with: initial-value
		return compiler translateExpression: expr

	is-translatable
		return true


extend Compiler SharedFieldSetter
	emit-call: arguments
		return 	--
			Expression 	--
				with: 'send' 	--
				with: (Expression with: 'quote' with: (field name + ":") intern) 	--
				with: on-proto access 	--
				with: arguments first-item jolt-expression

	translate-call: arguments compiler: compiler
		expr = 	--
			Expression 	--
				with: 'send' 	--
				with: (Expression with: 'quote' with: (field name + ":") intern) 	--
				with: on-proto access 	--
				with: arguments first-item
		return compiler translateExpression: expr


##### Inside a method.

extend Compiler LocalGetter
	emit-call: arguments
		return local name intern


extend Compiler LocalSetter
	emit-call: arguments
		return 	--
			Expression 	--
				with: 'set' 	--
				with: local name intern 	--
				with: arguments first-item jolt-expression


	translate-call: arguments compiler: compiler
		expr = 	--
			Expression with: 'set' with: local name intern with: arguments first-item
		return compiler translateExpression: expr


extend Compiler ArgumentFunction
	emit-call: arguments
		return name intern


extend Compiler SetArgumentFunction
	emit-call: arguments
		return 	--
			Expression 	--
				with: 'set' 	--
				with: name intern 	--
				with: arguments first-item jolt-expression

	translate-call: arguments compiler: compiler
		expr = Expression with: 'set' with: name intern with: arguments first-item
		return compiler translateExpression: expr


extend Compiler ThisFunction
	emit-call: arguments
		return 'self'


extend Compiler FunctionOnThis
	emit-call: arguments
		iff not-yet
			# Special-case instance functions.
			if build-settings optimize-field-accesses
				function = on-proto lookup-instance-function: name
				if function == nil
					# This would be a good place for a warning... or would we never get
					# here?
				else if function is-a: FieldGetter
					#...
				else if function is-a: FieldSetter
					#...
		
		# Emit the call.
		expr = Expression new: arguments count + 3
		expr at: 0 put: 'send'
		expr at: 1 put: (Expression with: 'quote' with: name intern)
		expr at: 2 put: 'self'
		index = 3
		for arg in arguments
			expr at: index put: arg jolt-expression
			index += 1
		return expr

	translate-call: arguments compiler: compiler
		expr = Expression new: arguments count + 3
		expr at: 0 put: 'send'
		expr at: 1 put: (Expression with: 'quote' with: name intern)
		expr at: 2 put: 'self'
		index = 3
		for arg in arguments
			expr at: index put: arg
			index += 1
		return compiler translateExpression: expr


##### Literals.

extend Compiler NilFunction
	emit-call: arguments
		return 'nil'


extend Compiler BoolLiteralFunction
	emit-call: arguments
		if value
			return 'true'
		else
			return 'false'


##### Inside statements.

extend Compiler CaughtExceptionFunction
	emit-call: arguments
		return 'exception'



# Copyright 2007 Steve Folta
# See the License file.

