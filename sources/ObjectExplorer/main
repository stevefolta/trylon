trylid ObjectExplorer


explore: object
	explorer = ObjectExplorer new: object
	explorer run


######

fields cur-object num-fields selected-field
fields field-names field-names-size
fields object-history

create: object
	object-history = List new
	use-object: object


use-object: object
	cur-object = object
	num-fields = (Pepsi SmallInteger value_: cur-object _sizeof) / 4
	selected-field = 0

	# Certain objects can't have their fields safely shown.
	if (object is-a: Pepsi Symbol) || (object is-a: Pepsi String) || 	--
	   (object is-a: Pepsi Float)
		num-fields = 0
	
	# Special-case Tuples, to see their contents.
	else if (object is-a: Tuple)
		num-fields += object num-items

	# Gather the field names.
	field-names = Tuple new: num-fields
	field-names-size = 0
	fill-field-names: cur-object vtable: cur-object _vtable
	if field-names-size > 0
		field-names-size += 3


show-object
	print: (ellipsize: cur-object print-string)
	print: "\r\n"
	print: "--------------------\r\n"
	which-field = 0
	while which-field < num-fields
		show-field: which-field
		print: "\r\n"
		which-field += 1


show-field: which-field
	# Print the field name.
	if field-names-size > 0
		field-name = field-names at: which-field
		columns-left = field-names-size
		if field-name && !(field-name is-empty)
			Standard print: field-name
			Standard print: ":  "
			columns-left -= field-name length + 3
		if columns-left > 0
			Standard print: "\e[" + columns-left string + "C"

	# Print the value.
	field-value = cur-object object-ptr object-at: which-field
	if which-field == selected-field
		Standard print: "\e[01m"
	print: (ellipsize: field-value print-string length: 72 - field-names-size)
	if which-field == selected-field
		Standard print: "\e[0m"


ellipsize: string length: max-length
	if string length > max-length
		string = (string substr: 0 length: max-length - 3) + "..."
	return string

ellipsize: string
	return ellipsize: string length: 72


field-down
	if selected-field >= num-fields - 1
		return
	selected-field += 1
	# Redraw old selection deselected.
	print: "\r\e[2K"
	show-field: selected-field - 1
	# Draw newly-selected field.
	print: "\e[B\r\e[2K"
	show-field: selected-field

field-up
	if selected-field <= 0
		return
	selected-field -= 1
	# Redraw current field unselected.
	print: "\r\e[2K"
	show-field: selected-field + 1
	# Draw newly-selected field.
	print: "\e[A\r\e[2K"
	show-field: selected-field


enter-field
	if num-fields <= 0
		return
	history-object = HistoricObject new: cur-object selected-field: selected-field
	object-history push-front: history-object
	switch-to-object: (cur-object object-ptr object-at: selected-field)


back-up
	if object-history is-empty
		return
	history-object = object-history pop-front
	switch-to-object: history-object object 	--
		selected-field: history-object selected-field


switch-to-object: object selected-field: new-selected-field
	# Clear the old object from the display.
	back-lines = 1
	if num-fields > 0
		back-lines = selected-field + 2
	print: "\e[" + back-lines string + "A\r\e[0J"

	# Go to the new object.
	use-object: object
	selected-field = new-selected-field
	show-object
	print: "\e[" + (num-fields - selected-field) string + "A"

switch-to-object: object
	switch-to-object: object selected-field: 0
	

run
	# Display the object.
	show-object
	print: "\e[" + (num-fields - selected-field) string + "A"

	# Put the input into "raw" (unbuffered) mode.
	saved-termios = Posix Termios new
	saved-termios get: 0
	termios = Posix Termios new
	termios get: 0
	termios cfmakeraw
	termios set: 0

	# Handle commands.
	input = Pepsi ByteArray new: 8
	c = nil
	peeking = false
	loop
		if !peeking
			Pepsi StdIn read: input size: 1
			c = input at: 0
			peeking = false
		switch c
			`q`
				break
			`j`
				field-down
			`k`
				field-up
			`\n`, `\r`, `l`
				enter-field
			`\b`, `u`, `h`
				back-up
			`\e`
				if (Pepsi StdIn waitForInput: 0) <= 0
					# ESC by itself.
					back-up
				else
					# Escape sequence, likely an arrow key.
					Pepsi StdIn read: input size: 1
					c = input at: 0
					if c == `[`
						Pepsi StdIn read: input size: 1
						c = input at: 0
						switch c
							`A`
								field-up
							`B`
								field-down
							`C`
								enter-field
							`D`
								back-up
							else
								# Unknown; just ignore it.
					else
						back-up
						peeking = true
	
	# Get to the last line.
	lines-down = num-fields - selected-field
	if lines-down > 0
		print: "\r\e[" + lines-down string + "B"

	# Restore terminal settings.
	saved-termios set: 0

	print-line


fill-field-names: object vtable: vtable
	# First fill in the fields from the superclass.
	super-num-fields = 0
	if vtable delegate
		super-num-fields = fill-field-names: object vtable: vtable delegate

	# If we have '.added-fields', use them.
	assoc = vtable findKeyOrNil: '.added-fields'
	if assoc
		closure = assoc value
		added-fields = nil
		coke
			(set added-fields ((long@ closure) closure object object))
		field-index = 0
		num-added-fields = added-fields size
		while field-index < num-added-fields
			field-name = (added-fields at: field-index) string
			if field-name length > field-names-size
				field-names-size = field-name length
			field-names at: super-num-fields + field-index put: field-name
			field-index += 1
	
	# Return the number of fields.
	assoc = vtable lookup: '_sizeof'
	_size = 0
	if assoc
		closure = assoc value
		coke
			(set _size ((long@ closure) closure object object))
	return (Pepsi SmallInteger value_: _size) / 4


#####

proto HistoricObject
	fields object selected-field

	create: object selected-field: selected-field
		this object = object
		this selected-field = selected-field

