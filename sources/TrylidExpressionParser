trylon TrylidExpressionParser

fields words line


create: words line
	this words = words
	this line = line


parse-expression
	expr = parse-keyword-expression
	if expr == nil
		return nil
	
	if words peek == ','
		tuple = TupleExpression new
		tuple add-member: expr
		while words peek == ','
			words next
			member = parse-keyword-expression
			if member == nil
				parse-error: "Missing expression in tuple."
			tuple add-member: member
		expr = tuple
	
	return expr


parse-keyword-expression
	expr = parse-binary-expression
	if expr == nil
		return nil
	
	if words peek ends-with: ":"
		name = ""
		args = List new
		while words peek ends-with: ":"
			name += words next text
			arg = parse-binary-expression
			if arg
				args append: arg
			else
				parse-error: "Missing argument (\"" + name + "\")."
		expr = Send new: name object: expr arguments: args
	
	return expr


parse-binary-expression
	# At the top level are the '=' expressions.

	expr = parse-logical-or-expression
	if expr == nil
		return nil
	
	expr2 = nil

	word = words peek
	if word == "="
		words next
		if !(expr is-a: FunctionCall) && !(expr is-a: Send)
			parse-error: "Illegal assignment."
		expr2 = parse-binary-expression
		if expr2 == nil
			expression-expected-after: word
		expr convert-to-setter-call: expr2
	
	else if word == "+=" || word == "-=" || word == "*=" || 	--
	        word == "/=" || word == "%=" || 	--
	        word == ">>=" || word == "<<=" || 	--
	        word == "&=" || word == "|=" || word == "^="
		words next
		if !(expr is-a: FunctionCall) && !(expr is-a: Send)
			parse-error: "Illegal assignment."
		expr2 = parse-expression
		if expr2 == nil
			expression-expected-after: word
		arguments = List new
		arguments append: expr2
		call = 	--
			Send new: (word substr: 0 length: word length - 1) 	--
			object: expr arguments: arguments
		setter = expr copy
		setter convert-to-setter-call: call
		expr = setter
	
	return expr


parse-logical-or-expression
	expr = parse-logical-and-expression
	if expr == nil
		return nil
	
	while words peek == "||"
		words next
		expr2 = parse-logical-and-expression
		if expr2 == nil
			expression-expected-after: "||"
		expr = ShortCircuitOr new: expr with: expr2
	
	return expr


parse-logical-and-expression
	expr = parse-inclusive-or-expression
	if expr == nil
		return nil
	
	while words peek == '&&'
		words next
		expr2 = parse-inclusive-or-expression
		if expr2 == nil
			expression-expected-after: "&&"
		expr = ShortCircuitAnd new: expr with: expr2
	
	return expr


parse-inclusive-or-expression
	expr = parse-exclusive-or-expression
	if expr == nil
		return nil
	
	while words peek == "|"
		words next
		expr2 = parse-exclusive-or-expression
		if expr2 == nil
			expression-expected-after: "|"
		expr = make-binop-call: "|" with: expr and: expr2
	
	return expr


parse-exclusive-or-expression
	return nil 	#...



# ===== Helpers


make-binop-call: name with: object and: argument
	arguments: List new
	arguments append: argument
	return Send new: name object: object arguments: arguments


parse-error: message
	throw ParseException new: message in: line

expression-expected-after: after
	parse-error: "Expression expected after \"" + after + "\"."


