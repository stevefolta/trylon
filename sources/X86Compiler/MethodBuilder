trylon MethodBuilder

fields refs out-ptr buffer-limit buffers

buffer-size = 512
buffer-slop-space = 32	# Enough space for the longest instruction.


create
	refs = List new
	buffers = List new
	grow


# Low-level emission.

# Code will be emitted into buffers, kept in a list.  At the end, the final
# code block is allocated (with the exact size) and the buffers are copied into
# it.  Only then are label-refs patched.

emit: opcode
	out-ptr put-byte: opcode
	out-ptr += 1
	offset += 1 	# Separate from out-ptr.
	if out-ptr >= buffer-limit
		grow

class Buffer
	fields ptr used-size
	
	create
		ptr = BytePtr new: buffer-size

grow
	# Finish the current buffer.
	buffer = buffers last-item
	if buffer
		buffer used-size = out-ptr - buffer ptr

	# Start a new buffer.
	buffer = Buffer new
	buffers append: buffer
	out-ptr = buffer ptr
	buffer-limit = out-ptr + buffer-size - buffer-slop-space


class Label
	fields offset

	define: offset
		this offset = offset

class LabelRef
	fields label offset


emit-label-ref: label
	ref = LabelRef new
	ref label = label
	ref offset = offset
	refs append: ref


class Loop
	fields continue-label break-label

start-loop-continue: continue-label break: break-label
	loop = Loop new
	loop continue-label = continue-label
	loop break-label = break-label
	loop-stack push: loop

end-loop
	loop-stack pop


# Compilation.

compile-if: stmt
	stmt condition compile: this
	emit: jne
	end = Label new
	emit-label-ref: end
	stmt body compile: this
	if stmt else-block
		# End the body by jumping past the else-branch
		final-end = Label new
		emit: jmp
		emit-label-ref: final-end

		# "end" currently means the end of the "if" branch; the conditional needs
		# to jump there.
		end define

		# Repurpose "end", so "final-end" is defined correctly.
		end = final-end
	end define: offset


compile-loop: stmt
	start = Label new
	start define: offset
	end = Label new
	start-loop-continue: start break: end
	stmt body compile: this
	emit: jmp
	emit-label-ref start
	end define: offset
	end-loop


compile-while: stmt
	start = Label new
	start define: offset
	end = Label new
	condition-result = stmt condition compile: this
	emit-test: condition-result
		# Could do nothing if the condition registers are already set.
	emit: je
	emit-label-ref: end
	start-loop-continue: start break: end
	stmt body compile: this
	emit: jmp
	emit-label-ref: start
	end define: offset
	end-loop


compile-for: stmt
	# Emit the creation of the iterator.
	# ...

	# Start the loop.
	again = Label new
	end = Label new
	start-loop-continue: again break: end

	# The test.
	test = Label new
	test define: offset
	done-result = emit-send-of: 'is-done' to: iterator-result with: empty
	emit-test: done-result
	emit: jne
	emit-label-ref: end

	# The body.
	value-result = emit-send-of: 'current-item' to: iterator-result with: empty
	emit-move-to: local from: value-result
	stmt body compile: this

	# Go around again.
	again define: offset
	emit-send-of: 'go-forward' to: iterator-result with: empty
	emit: jmp
	emit-label-ref: test

	# End the loop.
	end define: offset
	end-loop


