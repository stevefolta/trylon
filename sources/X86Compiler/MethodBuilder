trylon MethodBuilder

fields refs out-ptr buffer-limit buffers
fields dispatch-fn
fields postamble-label cur-num-locals num-locals

buffer-size = 512
buffer-slop-space = 32	# Enough space for the longest instruction.
word-size = 4

literals = nil


# NOTE:
# When assembly language is used in the comments, Intel-style syntax is used:
# 	mov dest, src


create
	init
	refs = List new
	buffers = List new
	grow

	dispatch-fn = dispatch-fn-addr


init
	if literals
		return
	
	literals = List new


emit-method
	postamble-label = Label new
	cur-num-locals = 0
	num-locals = 0

	# Set up arguments.
	argument-indices = Dictionary new
	index = 1 	# Index 0 is "this".
	for arg in arguments
		argument-indices at: arg name put: index
		index += 1

	# Emit the preamble.
	emit: 0x55 	# "push ebp"
	emit: (0x89, 0xE5) 	# "mov ebp, esp"
	emit: (0x81, 0xEC) 	# "sub esp, num-locals * 4"
	frame-size-offset = offset
	emit-word: 0 	# Will be patched later.

	# Emit the body of the code.
	body compile: this

	# Emit the postamble.
	postamble-label define: offset
	emit: 0xC9 	# "leave"
	emit: 0xC3 	# "ret"

	# Complete the last buffer.
	buffer = buffers last-item
	buffer used-size = out-ptr - buffer ptr

	# Assemble the buffers into the final code.
	code-size = 0
	for buffer in buffers
		code-size += buffer used-size
	code = BytePtr new: code-size
	dest = code
	for buffer in buffers
		dest copy-from: buffer ptr length: buffer used-size

	# Patch the frame size.
	# This is not done as a label since it's not relocated, only patched.
	(code + frame-size-offset) int-at: 0 put: num-locals * 4

	# Patch the labels.
	for ref in refs
		target = ref label offset
		if target == nil
			error: "Undefined label."
		(code + ref offset) int-at: 0 put: code + target


# Low-level emission.

# Code will be emitted into buffers, kept in a list.  At the end, the final
# code block is allocated (with the exact size) and the buffers are copied into
# it.  Only then are label-refs patched.

emit: opcodes
	for opcode in opcodes
		out-ptr byte-at: 0 put: opcode
		out-ptr += 1
		offset += 1 	# Separate from out-ptr.
		if out-ptr >= buffer-limit
			grow

emit-word: word
	out-ptr int-at: 0 put: word
	out-ptr += word-size
	offset += word-size
	if out-ptr >= buffer-limit
		grow

emit-ptr: ptr
	out-ptr ptr-at: 0 put: ptr
	out-ptr += word-size
	offset += word-size
	if out-ptr >= buffer-limit
		grow

emit-opcode-extensions-for: result
	emit: result mod-rm
	disp8 = result disp8
	if disp8
		emit: disp8
	disp32 = result disp32
	if disp32
		emit-word: disp32
	result = temp


class Buffer
	fields ptr used-size
	
	create
		ptr = BytePtr new: buffer-size
	
	create: size
		ptr = BytePtr new: size

grow
	# Finish the current buffer.
	buffer = buffers last-item
	if buffer
		buffer used-size = out-ptr - buffer ptr

	# Start a new buffer.
	buffer = Buffer new
	buffers append: buffer
	out-ptr = buffer ptr
	buffer-limit = out-ptr + buffer-size - buffer-slop-space


class Label
	fields offset

	define: offset
		this offset = offset

class LabelRef
	fields label offset

emit-label-ref: label
	ref = LabelRef new
	ref label = label
	ref offset = offset
	refs append: ref
	emit-word: 0


emit-push: result
	if result is-eax
		emit: 0x50 	# "push eax"
	else if result is-literal
		emit: 0x68	# "push imm32"
		emit-ptr: result ptr
	else
		emit: 0xFF 	# "push r/m32"
		mod-rm = result mod-rm
		mod-rm |= 6 << 3
		emit: mod-rm
		disp8 = result disp8
		if disp8
			emit: disp8
		disp32 = result disp32
		if disp32
			emit-word: disp32


emit-jmp: label
	emit: 0xB8 	# "mov eax, label"
	emit-label-ref: label
	emit: 0xFF 	# "jmp eax"
	emit: 0x20

jmp-length
	return 3 + word-size

emit-cond-jmp: cond to: label
	# Doesn't seem to be a good conditional jump with an absolute target.
	# Simulate it using the the relative jump we do have.
	# Emit the opcode -- opposite to our condition.
	switch cond
		'z'
			emit: 0x75 	# "jnz"
		'nz'
			emit: 0x74 	# "jz"
		else
			error: "Unknown opcode: " + cond string + "."
	emit: jmp-length
	# Emit the real, absolutely-addressed jump.
	emit-jmp: label


stash: result
	# If the result is already safely on the stack, simply return it.  If not,
	# stash it in a temporary.
	if result is-eax
		temp = get-temporary
		# "mov temp, eax"
		emit: 0x89
		emit-opcode-extensions-for: temp
		result = temp
	return result


class Local
	fields index

	create: index
		this index = index

new-local
	local = Local new: cur-num-locals
	cur-num-locals += 1
	if cur-num-locals > num-locals
		num-locals = cur-num-locals
	return local

get-temporary
	# A temporary is no different from any other local.
	return new-local


class Loop
	fields continue-label break-label

start-loop-continue: continue-label break: break-label
	loop = Loop new
	loop continue-label = continue-label
	loop break-label = break-label
	loop-stack push: loop

end-loop
	loop-stack pop


push-args: args
	reversed-args = List new
	for arg in args
		reversed-args push-back: arg
	for arg in reversed-args
		result = arg compile: this
		emit-push: result


emit-send-of: symbol to: object-result with: args
	# Push method args.
	object-result = stash: object-result
	push-args: args
	emit-push: object-result

	# Call Dispatch_().
	emit-push: object-result
	# "push selector"
	emit: 0x68
	emit-word: symbol selector
	# "mov eax, dispatch-fn"
	emit: 0xB8
	emit-ptr: dispatch-fn
	# "call [eax]"
	emit: 0xFF
	emit: 0x10
	emit-pop-args: 2

	# Call the method.
	# "call [eax]"
	emit: 0xFF
	emit: 0x10
	emit-pop-args: args num-items + 1
	return CallResult


c-fn dispatch-fn-addr
	return BuildBytePtr_(&Dispatch_);


emit-pop-args: num-args
	num-bytes = num-args * word-size
	if num-bytes < 127
		# More compact 8-bit form.
		emit: 0x83
		emit: 0xC4
		emit: num-bytes
	else
		emit: 0x81
		emit: 0xC4
		emit-word: num-bytes



# Statement compilation.

compile-block: block
	# Set up locals.
	exterior-num-locals = cur-num-locals
	if block locals
		for local in block locals
			local compile-info = new-local

	# Body.
	for stmt in block statments
		stmt compile: this
	
	# Clean up locals.
	cur-num-locals = exterior-num-locals

compile-block-statement: stmt
	return compile-block: stmt block


compile-comment: stmt
	# Nothing to do.

compile-blank-line: stmt
	# Nothing to do.


compile-if: stmt
	stmt condition compile: this
	end = Label new
	emit-cond-jmp: 'ne' to: end
	stmt body compile: this
	if stmt else-block
		# End the body by jumping past the else-branch
		final-end = Label new
		emit-jmp: final-end

		# "end" currently means the end of the "if" branch; the conditional needs
		# to jump there.
		end define

		# Repurpose "end", so "final-end" is defined correctly.
		end = final-end
	end define: offset


compile-loop: stmt
	start = Label new
	start define: offset
	end = Label new
	start-loop-continue: start break: end
	stmt body compile: this
	emit-jmp: label
	end define: offset
	end-loop


compile-while: stmt
	# "start:"
	start = Label new
	start define: offset
	end = Label new
	# condition
	condition-result = stmt condition compile: this
	emit-test: condition-result
	# "jne body"
	emit: (0x75, jmp-length)
	# "jmp end"
	emit-jmp: end
	# "body:"
	start-loop-continue: start break: end
	stmt body compile: this
	# "jmp start"
	emit-jmp: start
	# "end:"
	end define: offset
	end-loop


compile-for: stmt
	# Emit the creation of the iterator.
	# ...

	# Start the loop.
	again = Label new
	end = Label new
	start-loop-continue: again break: end

	# The test.
	test = Label new
	test define: offset
	done-result = emit-send-of: 'is-done' to: iterator-result with: empty
	emit-test: done-result
	emit-cond-jmp: 'ne' to: end

	# The body.
	value-result = emit-send-of: 'current-item' to: iterator-result with: empty
	emit-move-to: local from: value-result
	stmt body compile: this

	# Go around again.
	again define: offset
	emit-send-of: 'go-forward' to: iterator-result with: empty
	emit-jmp: test

	# End the loop.
	end define: offset
	end-loop


compile-return: stmt
	# ...


compile-try: stmt
	# ...


compile-throw: stmt
	# ...


compile-switch: stmt
	# ...


# Expression compilation.

compile-send: send
	object-result = send object compile: this
	return emit-send-of: send name intern to: object-result with: send arguments


compile-super-call: super-call
	# ...


compile-function-call: call
	return call function compile-call: this with: call arguments


compile-literal: value
	# We keep all literals in the "literals" list so the GC won't throw them out.
	literals append: value
	return LiteralResult new: value

compile-int-literal: literal
	return compile-literal: literal value

compile-char-literal: literal
	return compile-literal: literal value

compile-bool-literal: literal
	# Don't need to keep these on the list.
	return LiteralResult new: literal value

compile-float-literal: literal
	return compile-literal: literal value

compile-string-literal: literal
	return compile-literal: literal value

compile-symbol-literal: literal
	# Don't need to keep these on the list.
	return LiteralResult new: literal name intern

compile-literal-nil: literal
	# Don't need to keep this on the list.
	return LiteralResult new: nil

compile-dict-literal: literal
	dict = Dictionary new
	for pair in literal dict pairs
		# We know the result will be a LiteralResult.
		value-result = pair value compile: this
		dict at: pair name put: value-result value
	return compile-literal: dict


compile-tuple-expression: expr
	# Create the tuple.
	args = Tuple new: 1
	args at: 0 put: (IntLiteral new: expr members num-items)
	tuple-obj-result = LiteralResult new: Tuple
	tuple = emit-send-of: 'new:' to: tuple-obj-result with: args
	tuple = stash: tuple

	# Add the members.
	index = 0
	for member in expr members
		emit-send-of: 'at:put:' to: tuple with: (index-literal, member)
		index += 1

	return tuple


compile-short-circuit-and: expr
	# ...

compile-short-circuit-or: expr
	# ...

compile-short-circuit-not: expr
	# ...

compile-nil-test: expr
	# ...



# Function call compilation.

compile-this-call: func
	return ArgumentResult new: 0

compile-argument-call: func
	return ArgumentResult new: argument-indices[func name]

compile-set-argument-call: func with: arguments
	index = argument-indices[func name]
	value-result = arguments first-item compile: this
	arg-result = ArgumentResult new: index
	if !value-result is-eax
		# "mov eax, value-result"
		emit: 0x8B
		emit-opcode-extensions-for: value-result
	# "mov arg, eax"
	emit: 0x89
	emit-opcode-extensions-for: arg-result
	return arg-result

compile-local-getter-call: func
	return LocalResult new: func local compile-info index

compile-local-setter-call: func with: arguments
	index = func local compile-info index
	value-result = arguments first-item compile: this
	local-result = LocalResult new: index
	if !value-result is-eax
		# "mov eax, value-result"
		emit: 0x8B
		emit-opcode-extensions-for: value-result
	# "mov local, eax"
	emit: 0x89
	emit-opcode-extensions-for: local-result
	return local-result


compile-shared-field-getter-call: func
	# We could get more efficient here, but instead will just emit a send to the
	# proto.
	return 	--
		func 	--
			compile-send-of: func name to-proto: func on-proto with: empty using: this

compile-shared-field-setter-call: func with: arguments
	# We could get more efficient here, but instead will just emit a send to the
	# proto.
	return 	--
		func 	--
			compile-send-of: func name to-proto: func on-proto 	--
			with: arguments using: this


compile-function-on-this-call: func with: arguments
	this-result = ArgumentFunction new: 0
	emit-send-of: func name intern to: this-result with: arguments


compile-proto-call: func
	if func is-a: ExistingFunction
		return LiteralResult new: func proto
	else
		error: "Defining new classes is not yet supported in the X86 compiler."


compile-caught-exception-call: func
	# ...


compile-nil-call: func
	# Using "xor eax,eax".
	emit: 0x31
	emit: 0xC0
	return CallResult


compile-bool-literal-call: func
	if func value
		return LiteralResult new: true
	return LiteralResult new: false



# Copyright 2009 Steve Folta.  See the License file.

