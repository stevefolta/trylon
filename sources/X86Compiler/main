trylon X86Compiler

word-size = 4


compile: function
	# Function resolution.
	old-compiler = compiler
	compiler = this
	parse-tree = function body
	parse-tree prepare-to-emit

	# Codegen.
	method-builder = MethodBuilder new: function code: parse-tree
	result = method-builder emit-method

	compiler = old-compiler
	return result


replace-method: symbol on: object with: source arg-names: arg-names
	on-proto = Compiler ExistingProto new: object .proto
	arguments = List new
	for name in arg-names
		arguments append: (Compiler CompiledField new: name)

	# Parse.
	context = Compiler MethodContext new: arguments parent: on-proto
	lines = Compiler LinesLexer read: source
	parser = Compiler TrylonCodeParser new: lines in: context
	parse-tree = parser parse

	# Compile.
	function = 	--
		Compiler CompiledFunction 	--
			new: symbol string arguments: arguments return-type: nil 	--
			on-proto: on-proto body: parse-tree is-primitive: nil
	machine-code = X86Compiler compile: function

	# Replace the method.
	object .class install-method: symbol machine-code: machine-code


c-fn replace-method: symbol on: object with-ptr: fn-ptr
	#ifdef SUPPORT_NEW_METHODS_
		#ifdef SYMBOL_DISPATCH_
			fn_ptr_* method_ptr = MethodLocation_(object, symbol);
		#else
			struct Standard__Symbol__internal* sym =
				(struct Standard__Symbol__internal*) symbol;
			fn_ptr_* method_ptr = MethodLocation_(object, sym->selector);
		#endif
	#else
		fn_ptr_* method_ptr = nil;
	#endif
	if (method_ptr == nil) {
		UsingMethod_(method_replacement_error_co_)
		Call_(method_replacement_error_co_, this_, symbol);
		}
	*method_ptr = (fn_ptr_) BytePtrValue_(fn_ptr);
	return nil;

method-replacement-error: symbol
	error: "Unable to replace method '" + symbol string + "'."


# As a Compiler.

calling-selector: selector
	# Nothing to do.

build-settings
	if .build-settings == nil
		.build-settings = Compiler BuildSettings new
	return .build-settings
field .build-settings


references
	ExistingClassBuilder

