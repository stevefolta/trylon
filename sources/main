trylon main

compiler = nil

main: arguments
	return-value = 0
	try
		# Parse the arguments.
		file-names = List new
		compile-symbols = List new
		do-lex-test = false
		do-coke-lexer-test = false
		do-words-lexer-test = false
		do-lines-lexer-test = false
		for arg in arguments tail
			if arg starts-with: "--"
				compile-symbols append: (arg substr: 2)
				if arg == "--lex-test"
					do-lex-test = true
				else if arg == "--test-coke-lexer"
					do-coke-lexer-test = true
				else if arg == "--test-words-lexer"
					do-words-lexer-test = true
				else if arg == "--test-lines-lexer"
					do-lines-lexer-test = true
				else if arg == "--verbose" || 	--
				        arg == "--target-c" || arg == "--target-jolt"
					# Allowed.
				else
					throw MessageException new: ("Unknown option: " + arg)
			else
				file-names append: arg

		if do-lex-test
			for arg in arguments tail tail
				lex-test: arg
		else if do-coke-lexer-test
			for arg in arguments tail tail
				test-coke-lexer: arg
		else if do-words-lexer-test
			for arg in arguments tail tail
				test-words-lexer: arg
		else if do-lines-lexer-test
			for arg in arguments tail tail
				test-lines-lexer: arg

		else if !file-names is-empty
			for file-name in file-names
				Interpreter interpret: (File contents-of: file-name)

		else
			return-value = Compiler compile: compile-symbols
	
	catch Exception
		print-line: exception message
		return 1
	
	return return-value


iff targeting-jolt
	run-command-line
		CommandLine new run


status-reporter
	return compiler status-reporter

build-settings
	return compiler build-settings


debug: message
	iff debugging
		print-line: message

log: message
	status-reporter report: message
log-indent
	status-reporter indent
log-unindent
	status-reporter unindent


iff !targeting-jolt
	class Expression
		field tuple

		create: num-items
			tuple = Tuple new: num-items

		class-fn with: value
			expr = Expression new: 1
			expr at: 0 put: value
			return expr

		class-fn with: value-1 with: value-2
			expr = Expression new: 2
			expr at: 0 put: value-1
			expr at: 1 put: value-2
			return expr

		class-fn with: value-1 with: value-2 with: value-3
			expr = Expression new: 3
			expr at: 0 put: value-1
			expr at: 1 put: value-2
			expr at: 2 put: value-3
			return expr

		class-fn with: value-1 with: value-2 with: value-3 with: value-4
			expr = Expression new: 4
			expr at: 0 put: value-1
			expr at: 1 put: value-2
			expr at: 2 put: value-3
			expr at: 3 put: value-4
			return expr

		class-fn 	--
		  	with: value-1 with: value-2 with: value-3 with: value-4 with: value-5
			expr = Expression new: 5
			expr at: 0 put: value-1
			expr at: 1 put: value-2
			expr at: 2 put: value-3
			expr at: 3 put: value-4
			expr at: 4 put: value-5
			return expr

		at: index put: value
			tuple at: index put: value

		at: index
			return tuple at: index

		iterator
			return tuple iterator

		num-items
			return tuple num-items

		emit: stream
			reporter = nil
			iff debug-emission
				reporter = compiler status-reporter
				reporter report: "("
				reporter indent

			if num-items == 2 && (this at: 0) == 'quote'
				value = this at: 1
				if (value is-a: Symbol)
					c = value first-character
				  if (c < `A`) || (c >= `{`) || (c == `[`) || (c == `]`)
						# Special-case non-alpha symbols.
						stream write: "['\""
						stream write: value string
						stream write: "\" asSymbol]"
						return
				stream write: "'"
				emit-value: value on: stream
				iff debug-emission
					reporter unindent
				return

			else if num-items >= 3 && (this at: 0) == 'send' && 	--
			        ((this at: 1) is-a: Expression) && 	--
							((this at: 1) at: 0) == 'quote'
				stream write: "["
				emit-value: (this at: 2) on: stream
				stream write: " "
				emit-value: ((this at: 1) at: 1) on: stream
				index = 3
				while index < num-items
					stream write: " "
					emit-value: (this at: index) on: stream
					index += 1
				stream write: "]"
				return

			stream write: "("
			done-one = false
			for value in tuple
				if done-one
					stream write: " "
				else
					done-one = true
				emit-value: value on: stream
			stream write: ")"

			iff debug-emission
				reporter unindent
				reporter report: ")"

		emit-value: value on: stream
			if (value is-a: String) && !(value is-a: Symbol)
				stream write: "\""
				stream write: value
				stream write: "\""
			else if value is-a: Expression
				value emit: stream
			else
				stream write: value string

iff targeting-jolt
	class Expression
		superclass Pepsi Expression

		new: size
			return super new: size asInteger

		num-items
			return this size int

		at: index
			return super at: index asInteger

		at: index put: value
			super at: index asInteger put: value

		emit: stream
			reporter = nil
			iff debug-emission
				reporter = compiler status-reporter
				reporter report: "("
				reporter indent

			if num-items == 2 && (this at: 0) == 'quote'
				value = this at: 1
				if (value is-a: Pepsi Symbol)
					c = value string first-character
				  if (c < `A`) || (c >= `{`) || (c == `[`) || (c == `]`)
						# Special-case non-alpha symbols.
						stream write: "['\""
						stream write: value string
						stream write: "\" asSymbol]"
						return
				stream write: "'"
				emit-value: value on: stream
				iff debug-emission
					reporter unindent
				return

			if num-items >= 3 && (this at: 0) == 'send' && 	--
				 ((this at: 1) is-a: Expression) && 	--
			   ((this at: 1) at: 0) == 'quote'
				stream write: "["
				emit-value: (this at: 2) on: stream
				stream write: " "
				emit-value: ((this at: 1) at: 1) on: stream
				index = 3
				while index < num-items
					stream write: " "
					emit-value: (this at: index) on: stream
					index += 1
				stream write: "]"
				return

			stream write: "("
			index = 0
			while index < num-items
				if index > 0
					stream write: " "
				emit-value: (this at: index) on: stream
				index += 1
			stream write: ")"

			iff debug-emission
				reporter unindent
				reporter report: ")"

		emit-value: value on: stream
			if value is-a: String
				stream write: "\""
				stream write: value
				stream write: "\""
			else if value is-a: Expression
				value emit: stream
			else
				stream write: value string



# Test.

lex-test: filename
	try
		lexer = Compiler Lexer new: (File new: filename) contents
		loop
			token = lexer next-token
			print: token type
			if token text && !token text is-empty
				print: ": "
				print: token text
			print-line
			if token type == 'eof'
				break
	catch Exception
		print-line: "Error: " + exception message


test-coke-lexer: filename
	try
		lines = List new
		for line in (File new: filename) contents lines
			lines append: line
		lexer = Compiler CokeLexer new: lines
		loop
			expr = lexer next-expr
			if expr == nil
				break
			dump-expr: expr level: 0
			print-line
	catch Exception
		print-line: "Error: " + exception message


dump-expr: expr level: level
	print: ("                                   " substr: 0 length: level)
	if expr is-a: Expression
		print-line: "Expression (" + expr num-items string + ")"
		for item in expr
			dump-expr: item level: level + 1
	else if expr is-a: String
		print-line: "\"" + expr + "\""
	else
		print-line: expr string


test-words-lexer: filename
	try
		for line in (File new: filename) contents lines
			lexer = Compiler TrylonWordsLexer new: line
			while !lexer is-done
				print-line: lexer next
	catch Exception
		print-line: "Error: " + exception message


test-lines-lexer: filename
	try
		lexer = Compiler LinesLexer new: (File new: filename) contents
		lines = lexer lex
		dump-lines: lines level: 0
	catch Exception
		print-line: "Error: " + exception message


dump-lines: lines level: level
	for line in lines
		print: level string
		print: "> "
		print-line: line text
		if line block
			dump-lines: line block level: level + 1


references
	# Make sure these get loaded up; the old Trylon 1 compiler didn't like if if
	# the extensions came too late.
	CCompiler
	JoltCompiler
	Interpreter
	iff support-new-methods
		X86Compiler
		iff test-x86-compiler
			X86Compiler test



# Copyright 2007 Steve Folta.  See the License file.

