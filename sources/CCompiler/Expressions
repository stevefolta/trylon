trylon Expressions

extend Send
	emit-code: builder
		object-result = object emit-code: builder
		arg-results = List new
		for arg in arguments
			arg-results append: (arg emit-code: builder)
		builder using-object-function: name
		temporary = builder get-temporary
		line = temporary name + " = "
		line += "Call_(" + (mangle-name: name) + ", " + object-result access
		for arg-result in arg-results
			line += ", " + arg-result access
		line += ");"
		builder add-line: line
		return temporary


extend IntLiteral
	fields index 	# The MethodBuilder will set this.

	emit-code: builder
		builder int-literals add: this
		return LiteralResult new: this

	emit-declaration: stream
		stream write-all: ("DefineInt_(", index string, ", ", value string, ")\n")
	
	access
		return "Int_(" + index string + ")"
	

extend FloatLiteral
	field index

	emit-code: builder
		builder float-literals add: this
		return LiteralResult new: this
	
	emit-declaration: stream
		stream write-all: ("DefineFloat_(", index string, ", ", value string, ")\n")
	
	access
		return "Float_(" + index string + ")"
	

extend StringLiteral
	field	index 	# The MethodBuilder will set this.

	emit-code: builder
		builder string-literals add: this
		return LiteralResult new: this
	
	emit-declaration: stream
		stream write-all: ("DefineString_(", index string, ", ", value string, ")\n")
	
	access
		return "String_(" + index string + ")"


extend SymbolLiteral
	emit-code: builder
		mangled-name = mangle-name: name
		builder add-extern-declaration: "UsingSym_(" + mangled-name + ")"
		return NameResult new: "Sym_(" + mangled-name + ")" is-constant: true


extend LiteralNil
	emit-code: builder
		return NameResult new: "nil" is-constant: true


extend BoolLiteral
	emit-code: builder
		result = nil
		if value
			result = 'true_'
		else
			result = 'nil'
		return NameResult new: result is-constant: true


extend CharacterLiteral
	# Just another form of IntLiteral.
	fields index 	# The MethodBuilder will set this.

	emit-code: builder
		builder int-literals add: this
		return LiteralResult new: this
	
	emit-declaration: stream
		stream write-all: ("DefineInt_(", index string, ", ", char string, ")\n")
	
	access
		return "Int_(" + index string + ")"
	

extend DictLiteral
	field	index results
	field next-node-index

	emit-code: builder
		builder using-proto: (the-compiler get-standard-proto: "Dictionary")

		# Access all values first, so sub-dicts get declared first.
		next-node-index = 0
		results = build-results: root builder: builder

		builder dict-literals add: this
		return LiteralResult new: this
	
	class ResultsNode
		fields left right key value level dict node-index

		create: node-index in: dict
			this node-index = node-index
			this dict = dict

		emit-declaration-on: stream
			left-access = 'nil'
			if left
				left emit-declaration-on: stream
				left-access = left access
			right-access = 'nil'
			if right
				right emit-declaration-on: stream
				right-access = right access
			stream write-all: 	--
				("DefineDictNode_(", index string, ", ", index string, ", ", 	--
				 key access, ", ", value access, ", ", 	--
				 left-access, ", ", right-access, ", ", level string, ")\n")

		access
			return "DictNode_(" + dict index string + ", " + node-index string + ")"
	
	build-results: node builder: builder
		results = ResultsNode new: next-node-index
		next-node-index += 1
		if node left
			results left = build-results: node left builder: builder
		if node right
			results right = build-results: node right builder: builder
		# Keys and values are constants which will not be allowed to emit code, so
		# we can call emit-code: on them without fear that they'll actually emit
		# code.  The side-effect is that they set up the builder to declare them.
		results key = (StringLiteral new: node key) emit-code: builder
		results value = node value emit-code: builder
		results level = node level
		return results
	
	emit-declaration: stream
		root = results emit-declaration-on: stream
		stream write-all: 	--
			("DefineDict_(", index string, ", ", root access, ", ", 	--
			 dict num-items string, ")\n")
	
	access
		return "Dict_(" + index string + ")"
	


