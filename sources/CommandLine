trylon CommandLine
fields prompt post-prompt

create
	prompt = "\n\e[34m> \e[0;01m"
	post-prompt = "\e[0m"

	# Set up history.
	coke
		(using_history)
		(stifle_history 1000)
		(read_history ".trylon-history")
		[[Posix Stdlib] atexit_: (lambda () (write_history ".trylon-history"))]

	# Unknown messages should throw, not exit.
	coke
		(define-send (quote doesNotUnderstand:) Object selector
			(begin
				(define message [self string])
				(set message [message + (trylon-string " doesn't understand '")])
				(set message [message + [selector string]])
				(set message [message + (trylon-string "'")])
				(throw [(trylon-proto Standard MessageException) new: message])
				))


readline
	_prompt = prompt _stringValue
	coke
		(let ((result (readline _prompt)))
			(if result
				(let ((return-value [StandardString new-copy_: result]))
					(free result)
					return-value)
				nil))


run
	context = Context new: this
	last-line = ""
	loop
		line = readline
		print: post-prompt
		if line == nil
			break
		line = line trimmed
		if line is-empty
			continue
		if line != last-line
			coke
				(add_history [line _stringValue])
			last-line = line
		try
			lines = (Trylon LinesLexer new: line + "\n") lex
			line = lines first-item
			words = Trylon WordsLexer new: line
			parser = 	--
				Compiler ExpressionParser new: words line: line context: context
			parser = Compiler Parser new: line context: context
			expr = parser parse-expression
			if expr
				result = expr _eval
				print-line: result print-string
			else
				print-line: "\e[31mUnknown compile error.\e[0m"
		else
			print-line: "\e[31m" + exception message + "\e[0m"
	print-line
	coke
		(write_history ".trylon-history")


proto Context
	# Ought to work:
	# superclass Compiler Context
	fields command-line parent

	create: command-line
		this command-line = command-line
		parent = Compiler ExistingClass new: "command-line" proto: command-line
	
	lookup-function: name
		return parent lookup-function: name

	lookup-function-autodeclaring: name
		result = lookup-function: name
		if result
			return result

		if name == "true"
			return Compiler BoolLiteralFunction new: true
		else if name == "false"
			return Compiler BoolLiteralFunction new: false

		if (name index-of: `:`) == name length - 1
			# Autodeclare it as a shared field in the command-line.
			field-name = name substr: 0 length: name length - 1
			field-name-symbol = field-name intern
			coke
				(add-shared-field-to field-name-symbol [self command-line] nil)
			field = Compiler CompiledField new: field-name
			return Compiler SharedFieldSetter new: field on-proto: parent

		return nil
	
	enclosing-method-context
		return nil



##### Useful functions from the command line.

load: filename into: proto
	if filename ends-with: "/"
		filename = filename substr: 0 length: filename length - 1
	dir-path = "."
	proto-name = filename
	slash-index = filename last-index-of: `/`
	if slash-index >= 0
		proto-name = filename substr: slash-index + 1
		dir-path = filename substr: 0 length: slash-index
	directory = FileDirectory new: dir-path
	if directory entry-is-directory: proto-name
		(Compiler new) 	--
			compile-dir: (directory at: proto-name) as: proto-name into: proto
	else
		(Compiler new) compile-file: (File new: filename) as: proto-name into: proto


load: filename
	load: filename into: this


explore: object
	ObjectExplorer explore: object



