trylon CompiledProto
superclass Context

fields name parent functions fields shared-fields superclass directories
fields uses-protos subclasses
fields is-main is-root-object


create: name parent: parent
	this name = name
	this parent = parent
	functions = Dictionary new
	fields = List new
	shared-fields = Dictionary new
	directories = List new
	uses-protos = List new
	subclasses = List new
	is-main = false
	is-root-object = false

	# Will be added by Jolt code:
	add-function: (PrimitiveFunction new: ".proto" on-proto: this)
	add-function: (PrimitiveFunction new: ".parent-proto" on-proto: this)


lookup-function: name
	return lookup-function: name visited-protos: ObjectMap new


lookup-function: name visited-protos: visited-protos
	# Recursion control.
	if visited-protos contains: this
		return nil
	visited-protos at: this put: this

	# Do we know it already?
	function = functions at: name
	if function
		return function
	
	# If not, see if it's in one of our directories.
	for directory in directories
		# A file?
		if (directory contains: name) && !(directory entry-is-directory: name)
			proto = add-proto: name
			parser = Parser new: (directory at: name) contents context: this
			parser parse-proto-file: proto
			return functions at: name

		# A directory?
		if directory entry-is-directory: name
			add-proto: name directory: (directory at: name)
			return functions at: name
	
	# Check the parent.
	if parent
		function = parent lookup-function: name visited-protos: visited-protos
		if function
			return function
	
	# Next, check the used protos.
	for used-proto in uses-protos
		function = 	--
			used-proto lookup-function: name visited-protos: visited-protos
		if function
			return function
	
	return nil


lookup-instance-function: name
	function = functions at: name
	if function
		return function
	
	if superclass
		return superclass lookup-instance-function: name
	
	return nil


make-subclass-of: superclass
	if this superclass
		# Already had a superclass (perhaps the default Standard Object); 
		# replace it.
		uses-protos remove: this superclass
	
	# Install the superclass.
	this superclass = superclass
	superclass subclasses append: this

	# Automatically "use" the superclass.
	uses-protos append: superclass


add-function: function
	function-name = function name
	if function has-code
		existing-function = functions at: function-name
		if existing-function && existing-function has-code
			throw MessageException new: 	--
				"\"" + this name + " " + function-name + "\" is defined twice."

	functions at: function-name put: function
	the-compiler declaring-selector: function-name

	# "create" functions automatically add a corresponding "new:" function.
	if (function is-a: CompiledFunction) && 	--
	    ((function-name == "create") || 	--
			 (function-name starts-with: "create:") || 	--
	     (function-name starts-with: "create-"))
		# Add the corresponding "new" function.
		new-function = NewFunction new: function on-proto: this
		(functions at: new-function name) = new-function


add-function: name function: function
	functions at: name put: function
	the-compiler declaring-selector: name


add-field: field
	fields append: field
	add-function: field name 	--
		function: (FieldGetter new: field on-proto: this)
	add-function: field name + ":" 	--
		function: (FieldSetter new: field on-proto: this)


add-shared-field: field
	shared-fields at: field name put: field
	functions at: field name put: (SharedFieldGetter new: field on-proto: this)
	functions 	--
		at: field name + ":" put: (SharedFieldSetter new: field on-proto: this)


add-proto: name directory: directory
	# If it already exists, return it.
	existing-function = functions at: name
	if existing-function
		if !(existing-function is-a: ProtoFunction)
			throw MessageException new: 	--
				"Adding \"" + name + "\" as a proto, when it's already a non-proto."
		return existing-function proto
	
	# Add the new one.
	status-reporter = the-compiler status-reporter
	status-reporter report: "Loading " + name + " into " + full-name + "..."
	status-reporter indent
	new-proto = CompiledProto new: name parent: this
	if directory
		new-proto add-directory: directory
	proto-function = ProtoFunction new: new-proto
	functions at: name put: proto-function
	the-compiler proto-queue append: new-proto
	status-reporter unindent
	return new-proto


add-proto: name
	return add-proto: name directory: nil


get-subproto: name
	# Has it been loaded already?
	function = functions at: name
	if function && (function is-a: ProtoFunction)
		return function proto
	
	# Look for it.
	for directory in directories
		if directory entry-is-directory: name
			return add-proto: name directory: (directory at: name)
		else if directory contains: name
			proto = add-proto: name
			parser = Parser new: (directory at: name) contents context: this
			parser parse-proto-file: proto
			return proto
	
	return nil


get-proto: name
	function = functions at: name
	if function == nil
		function = lookup-function: name
	if function && (function is-a: ProtoFunction)
		return function proto
	return nil


add-directory: directory
	directories append: directory

	if directory contains: "main"
		parser = Parser new: (directory at: "main") contents context: this
		parser parse-proto-file: this


setup-main: main-directory library-directory: library-directory
	is-main = true

	# We want the main-directory to have precedence when looking up names,
	# but we won't be able to compile its "main" until the library directory
	# is in the "directories" and Standard is visible.  So add both, *then*
	# compile the "main"s.
	directories append: main-directory
	directories append: library-directory

	# Load Standard.
	standard-proto = get-subproto: "Standard"
	if standard-proto == nil
		throw MessageException new: "The Standard proto can't be found!"
	uses-protos append: standard-proto

	# Targeting Jolt.
	if the-compiler build-settings targeting-jolt
		standard-proto get-subproto: "JoltImplementation"

		# Set up Posix.
		posix-directory = library-directory at: "Posix"
		posix-proto = PosixProto new: "Posix" parent: this directory: posix-directory
		proto-function = ProtoFunction new: posix-proto
		functions at: "Posix" put: proto-function
		the-compiler proto-queue append: posix-proto

		# Set up Standard Pepsi.
		standard-directory = library-directory at: "Standard"
		pepsi-proto = PepsiProto new: "Pepsi" parent: standard-proto
		proto-function = ProtoFunction new: pepsi-proto
		standard-proto functions at: "Pepsi" put: proto-function
		parser = 	--
			Parser new: (standard-directory at: "Pepsi") contents 	--
				context: standard-proto
		parser parse-proto-file: pepsi-proto
		the-compiler proto-queue append: pepsi-proto
	
	# Targeting C.
	if the-compiler build-settings targeting-c
		standard-proto get-subproto: "CImplementation"

	# Add "nil", "true", and "false" to Standard.
	standard-proto functions at: "nil" put: NilFunction new
	standard-proto functions at: "true" put: (BoolLiteralFunction new: true)
	standard-proto functions at: "false" put: (BoolLiteralFunction new: false)

	# Load our "main"s
	for directory in directories
		if directory contains: "main"
			parser = Parser new: (directory at: "main") contents context: this
			parser parse-proto-file: this
	
	# Load up standard protos.
	std-protos = ("BytePtr", "Int", "String", "Float", "Symbol", "Tuple", "List")
	for proto-name in std-protos
		standard-proto lookup-function: proto-name
	
	# Self.
	functions at: name put: (ProtoFunction new: this)


ensure-superclasses: object-proto
	if superclass == nil && object-proto != this
		make-subclass-of: object-proto
	for function in functions values
		if function is-a: ProtoFunction
			proto = function proto
			if proto != this
				proto ensure-superclasses: object-proto


prepare-to-emit
	if superclass == nil
		ensure-superclasses: (the-compiler get-standard-class: "Object")
	
	for function in functions values
		function prepare-to-emit


emit-code
	status-reporter = the-compiler status-reporter
	status-reporter report: "Generating code for " + name + "..."
	status-reporter indent

	if the-compiler build-settings is-verbose
		status-reporter report: name + " has these functions:"
		status-reporter indent
		for name in functions keys
			status-reporter report: name
		status-reporter unindent
	
	is-changed = emit-jolt-file

	status-reporter unindent

	is-changed = true
	return is-changed


emit-jolt-file
	status-reporter = the-compiler status-reporter
	iff debug-emission
		status-reporter report: "Emitting " + name + "..."
		status-reporter indent

	# Open the file.
	file = 	--
		File new: 	--
			the-compiler build-settings jolt-sources-dir + "/" + full-name + ".k"
	stream = ExistingFileStream new: file

	# Define the proto.
	# ...but not for Trylid or Standard Object (which are created specially in
	# (setup-Trylid)).
	if parent && superclass
		parent-access = parent access
		superclass-access = superclass access
		slots = Expression new: fields count
		index = 0
		for field in fields
			slots at: index put: field name intern
			index += 1
		expr = 	--
			Expression 	--
				with: 'define-trylid-proto' 	--
				with: name intern 	--
				with: parent-access 	--
				with: superclass-access 	--
				with: slots
		expr emit: stream
		stream write-line
		stream write-line

	# Add loaders for the subprotos.
	got-one = false
	for function in functions values
		if function is-a: ProtoFunction
			compiled-code = function emit-code
			if compiled-code
				compiled-code emit: stream
				stream write-line
				got-one = true
	if got-one
		stream write-line

	# Add '.used-contexts'.
	if !(uses-protos is-empty)
		tuple-expr = Expression new: uses-protos count + 1
		tuple-expr at: 0 put: 'trylid-tuple'
		index = 1
		for proto in uses-protos
			tuple-expr at: index put: proto access
			index += 1
		expr = 	--
			Expression 	--
				with: 'add-constant-field' 	--
				with: '.used-contexts' 	--
				with: access 	--
				with: tuple-expr
		expr emit: stream
		stream write-line
		stream write-line

	# Compile all the functions.
	for function in functions values
		if function is-a: ProtoFunction
			continue
		iff debug-function-emission
			status-reporter report: "Emitting " + function name + "..."
			status-reporter indent
		compiled-code = function emit-code
		if compiled-code
			compiled-code emit: stream
			stream write-line
			iff hacky-backtrace
				stream write-line: "(name-last-lambda \"" + function name + "\")"
			stream write-line
		iff debug-function-emission
			status-reporter unindent
	
	iff debug-loading
		stream write-line: "(say \"; " + name + " loaded.\")"

	stream close
	iff debug-emission
		status-reporter unindent


iff targeting-jolt
	translate: compiler
		# Make sure there's a superclass.
		if superclass == nil
			superclass = ExistingProto new: "Object" proto: Object

		# Start creating the big expression that creates the proto and all its
		# components.
		stream = Pepsi WriteStream on: (Expression new: functions count + 1)
		stream nextPut: 'begin'

		# Define the proto.
		slots = Expression new: fields count
		index = 0
		for field in fields
			slots at: index put: field name intern
			index += 1
		expr = 	--
			Expression 	--
				with: 'define-trylid-proto' 	--
				with: name intern 	--
				with: parent access 	--
				with: superclass access 	--
				with: slots
		stream nextPut: expr

		# ... We may need to add loaders for any subprotos, to deal with
		# dependencies.

		# Add the functions.
		for function in functions values
			if function is-translatable
				function prepare-to-emit
				stream nextPut: function

		return compiler translateExpression: stream contents


access
	if is-main
		return 'Trylid'
	else if is-root-object
		return 'trylid-root-object'
	else
		iff not-anymore
			return 	--
				Expression 	--
					with: 'send' 	--
					with: (Expression with: 'quote' with: name intern) 	--
					with: parent access
		list = List new
		namespace = this
		while !namespace is-main
			list push-front: namespace
			namespace = namespace parent
		expr = Expression new: list count + 1
		expr at: 0 put: 'trylid-proto'
		index = 1
		for namespace in list
			expr at: index put: namespace name intern
			index += 1
		return expr



# Helpers

full-name
	if is-main
		return name
	result = this name
	proto = parent
	while !proto is-main
		result = proto name + " " + result
		proto = proto parent
	return result



# Copyright 2007 Steve Folta.  See the License file.

