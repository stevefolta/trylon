trylon Compiler

fields arguments successful build-settings
fields proto-queue main-proto
fields status-reporter


class-fn compile: arguments
	the-compiler = Compiler new: arguments
	the-compiler run
	return the-compiler return-value


create: arguments
	this arguments = arguments
	this successful = true
	this build-settings = BuildSettings new
	proto-queue = List new


run
	try
		# Read the settings.
		build-settings load

		# Parse the arguments.
		file-names = List new
		compile-symbols = List new
		do-lex-test = false
		do-coke-lexer-test = false
		do-words-lexer-test = false
		do-lines-lexer-test = false
		for arg in arguments tail
			if arg starts-with: "--"
				compile-symbols append: (arg substr: 2)
				if arg == "--lex-test"
					do-lex-test = true
				else if arg == "--test-coke-lexer"
					do-coke-lexer-test = true
				else if arg == "--test-words-lexer"
					do-words-lexer-test = true
				else if arg == "--test-lines-lexer"
					do-lines-lexer-test = true
				else if arg == "--verbose"
					build-settings is-verbose = true
				else
					throw MessageException new: ("Unknown option: " + arg)
			else
				file-names append: arg

		if status-reporter == nil
			if build-settings is-verbose
				status-reporter = StdoutStatusReporter new
			else
				status-reporter = VT100StatusReporter new

		if do-lex-test
			for arg in arguments tail tail
				lex-test: arg
		else if do-coke-lexer-test
			for arg in arguments tail tail
				test-coke-lexer: arg
		else if do-words-lexer-test
			for arg in arguments tail tail
				test-words-lexer: arg
		else if do-lines-lexer-test
			for arg in arguments tail tail
				test-lines-lexer: arg

		else
			compile-program: compile-symbols
	
	catch Exception
		print-line: exception message
		successful = false


return-value
	if !successful
		return 1
	return 0



# Top-level compilation.

compile-program: compile-symbols
	# Create the .jolt-sources directory.
	directory = FileDirectory new: "."
	if !(directory entry-is-directory: build-settings jolt-sources-dir)
		directory create-subdirectory: build-settings jolt-sources-dir
	
	# Load.
	main-directory = FileDirectory new: "."
	if main-directory entry-is-directory: "sources"
		main-directory = main-directory at: "sources"
	library-path = find-library-path
	if library-path == nil
		throw MessageException new: 	--
			"Couldn't find the Trylid library.  You may need to set $TRYLID_LIBRARY."
	library-directory = FileDirectory new: library-path
	status-reporter report: "Loading Main..."
	status-reporter indent
	main-proto = CompiledProto new: "Main" parent: nil
	main-proto 	--
		setup-main: main-directory library-directory: library-directory 	--
		compile-symbols: compile-symbols
	proto-queue append: main-proto
	status-reporter unindent

	# Get ready to emit (mainly this makes sure all used classes are loaded).
	status-reporter report: "Preparing to emit..."
	status-reporter indent
	for proto in proto-queue
		proto prepare-to-emit
	status-reporter unindent

	# Make every class without a superclass be a subclass of Standard Object.
	object-class = root-proto: main-proto
	object-class is-root-object = true
	main-proto ensure-superclasses: object-class

	# Emit the classes and packages.
	status-reporter report: "Emitting code..."
	status-reporter indent
	for proto in proto-queue
		is-changed = proto emit-code
	status-reporter unindent

	# Another round of ensure-superclasses, to get classes loaded during 
	# the emit.
	# (This might not be necessary, now that "CompiledProto prepare-to-emit"
	# ensures that it has a superclass).
	main-proto ensure-superclasses: object-class

	status-reporter report: "Done."


root-proto: main-proto
	# Find "Standard Object".
	standard-package = main-proto get-subproto: "Standard"
	if standard-package == nil
		throw MessageException new: "Standard package is missing!"
	object-function = standard-package lookup-function: "Object"
	if object-function == nil
		throw MessageException new: "Standard Object is missing!"
	if !object-function is-a: ProtoFunction
		throw MessageException new: "Standard Object is not a prototype!"
	return object-function proto


report-run-program: program arguments: args
	if build-settings is-verbose
		status-reporter indent

		command = StringBuilder new
		command += program
		command += " "
		for arg in args
			command += arg
			command += " "
		status-reporter report: command string

		status-reporter unindent


get-standard-class: name
	return (main-proto get-subproto: "Standard") get-proto: name


find-library-path
	library-path = System environment-variable-named: "TRYLID_LIBRARY"
	if library-path && !library-path is-empty
		return library-path
	for prefix-path in ("/usr/lib", "/usr/local/lib", "/opt/lib")
		prefix-dir = FileDirectory new: prefix-path
		if prefix-dir entry-is-directory: "trylon"
			return prefix-path + "/trylon"
	return nil


# Test.

lex-test: filename
	try
		lexer = Lexer new: (File new: filename) contents
		loop
			token = lexer next-token
			print: token type
			if token text && !token text is-empty
				print: ": "
				print: token text
			print-line
			if token type == 'eof'
				break
	catch Exception
		print-line: "Error: " + exception message


test-coke-lexer: filename
	try
		lines = List new
		for line in (File new: filename) contents lines
			lines append: line
		lexer = CokeLexer new: lines
		loop
			expr = lexer next-expr
			if expr == nil
				break
			dump-expr: expr level: 0
			print-line
	catch Exception
		print-line: "Error: " + exception message


dump-expr: expr level: level
	print: ("                                   " substr: 0 length: level)
	if expr is-a: Expression
		print-line: "Expression (" + expr num-items string + ")"
		for item in expr
			dump-expr: item level: level + 1
	else if expr is-a: String
		print-line: "\"" + expr + "\""
	else
		print-line: expr string


test-words-lexer: filename
	try
		for line in (File new: filename) contents lines
			lexer = WordsLexer new: line
			while !lexer is-done
				print-line: lexer next
	catch Exception
		print-line: "Error: " + exception message


test-lines-lexer: filename
	try
		lexer = LinesLexer new: (File new: filename) contents
		lines = lexer lex
		dump-lines: lines level: 0
	catch Exception
		print-line: "Error: " + exception message


dump-lines: lines level: level
	for line in lines
		print: level string
		print: "> "
		print-line: line text
		if line block
			dump-lines: line block level: level + 1


