trylon ExistingProto
superclass ClassContext

fields name proto new-functions is-main


create: name proto: proto
	this name = name
	this proto = proto
	new-functions = Dictionary new

create: proto
	create: proto .proto-name proto: proto


lookup-function: name
	name-selector = name intern

	# Are we adding it?
	function = new-functions at: name
	if function
		return function
	
	# Check the context, starting here.
	cur-proto = proto
	loop
		# Is it directly visible?
		function = function-for: name-selector in: cur-proto
		if function
			return function

		# Is it visible due to being in a "used" context?
		if cur-proto responds-to: '.used-contexts'
			for context in cur-proto .used-contexts
				function = function-for: name-selector in: context
				if function
					return function

		# Go up a level.
		if !(cur-proto responds-to: '.parent-context')
			break
		cur-proto = cur-proto .parent-context
		if cur-proto == nil
			break
	
	return nil

function-for: selector in: proto
	if !(proto responds-to: selector)
		return nil
	
	# Is it a ProtoFunction?
	function-name = selector string
	if (function-name index-of: `:`) < 0
		# 'support-subprotos' must be on!
		found-subproto = nil
		if proto .subprotos
			for subproto in proto .subprotos
				if subproto .proto-name == function-name
					found-subproto = subproto
					break
		if found-subproto
			existing-proto = ExistingProto new: function-name proto: found-subproto
			return ProtoFunction new: existing-proto

	existing-proto = this
	if proto != this
		existing-proto = ExistingProto new: proto .proto-name proto: proto
	return PrimitiveFunction new: function-name on-proto: existing-proto


lookup-function: name visited-protos: visited-protos
	return lookup-function: name


lookup-instance-function: name
	if proto responds-to: name intern
		first-char = name at: 0
		if (first-char >= `A`) && (first-char <= `Z`)
			existing-proto = 	--
				ExistingProto new: name proto: (proto perform: name intern)
			return ProtoFunction new: existing-proto
		return PrimitiveFunction new: name on-proto: proto
	
	function = new-functions at: name
	if function
		return function

	return nil


parent
	if proto responds-to: '.parent-context'
		parent-context = proto .parent-context
		existing-proto = ExistingProto new: parent-context
		iff targeting-jolt
			if parent-context == Trylon
				existing-proto is-main = true
		iff !targeting-jolt
			if parent-context == Main
				existing-proto is-main = true
		return existing-proto
	return nil


add-function: function
	function-name = function name

	new-functions at: function-name put: function

	# "create" functions automatically add a corresponding "new:" function.
	if (function is-a: CompiledFunction) && 	--
	    ((function-name == "create") || 	--
			 (function-name starts-with: "create:") || 	--
	     (function-name starts-with: "create-"))
		# Add the corresponding "new" function.
		new-function = NewFunction new: function on-proto: this
		(new-functions at: new-function name) = new-function


add-function: name function: function
	new-functions at: name put: function


add-field: field
	# Fields can't be added to pre-existing protos.  But we may be re-loading the
	# proto to update its methods, so check if we're merely trying to add a field
	# that's already there.
	# This is not a perfect check; we merely check to see if there's a getter and
	# a setter, not if there's truly a field.
	if lookup-instance-function: field name
		if lookup-instance-function: field name + ":"
			return

	throw MessageException new: "You can't add fields to pre-existing objects."


add-shared-field: field
	new-functions at: field name put: (SharedFieldGetter new: field on-proto: this)
	new-functions 	--
		at: field name + ":" put: (SharedFieldSetter new: field on-proto: this)


add-proto: name directory: directory
	# If it already exists, return it.
	existing-function = lookup-instance-function: name
	if existing-function
		if !(existing-function is-a: ProtoFunction)
			throw MessageException new: 	--
				"Adding \"" + name + "\" as a proto, when it's already a non-proto."
		return existing-function proto
	
	# Add the new one.
	status-reporter = compiler status-reporter
	status-reporter report: "Loading " + name + " into " + this name + "..."
	status-reporter indent
	new-proto = CompiledProto new: name parent: this
	if directory
		new-proto add-directory: directory
	proto-function = ProtoFunction new: new-proto
	new-functions at: name put: proto-function
	status-reporter unindent
	return new-proto


add-proto: name
	return add-proto: name directory: nil


source-name: name
	# We don't care.


get-subproto: name
	# Has it been loaded already?
	function = lookup-instance-function: name
	if function && (function is-a: ProtoFunction)
		return function proto
	
	return nil


get-proto: name
	function = new-functions at: name
	if function == nil
		function = lookup-function: name
	if function && (function is-a: ProtoFunction)
		return function proto
	return nil


newly-defined-functions
	return new-functions pairs


# Copyright 2007 Steve Folta.  See the License file.

