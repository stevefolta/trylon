[2007.3.4]

Go for fully dynamic:  A special dispatch provides for lazy loading of member protos.  A ProtoBuilder greedily reads the source(s), then builds the proto (now that it knows the number of ivars), then compiles the methods.  That means the methods are grabbed as text, and the parser can know at the time of parse-primary whether it needs to auto-declare.

Trylon objects get a special vtable that also checks (and knows) the enclosing context.

Just use "arg"/"args" for lambdas:

	collection each:
		arg item
		item println


=====

[2007.3.21]

Equals-block should make a new object, not a dict literal:

	trylid List
	fields head last

	create
		head = last = nil
	
	append: new-value
		new-cell = Cell new: value
		if last
			last tail = new-cell
		else
			head = new-cell
		last = new-cell

	Cell =
		fields head tail

		create: value
			head = value

But that should still serve the dict-literal purpose (and even better: 'dict entry' vs. 'dict at: "entry"').


=====

[2007.3.23]

All fields supporting the use of protos as packages (subproto names, ".parent-context", etc.) should be shared fields.

Will need:
	.proto
	.proto-name
	.parent-context


=====

Loading
	[2007.3.25]

Standard Object must be loaded first, and can't join Standard until later.  Use a (namespace ...) function instead of sends to access parent namespaces, and don't specify Main in its arguments -- (namespace Standard), (namespace Standard Implementation).  It will dynamically check to see if the namespace is loaded and load it from the .k file if not.  Or call it (load-trylid-proto), or just (trylid-proto).  So something like this:

	(define trylid-root-object (read-trylid-proto-file "Standard Object.k"))
	(setup-Main)
	(read-trylid-proto-file "Main.k")
		;; Should result in everything else getting loaded.

Standard Object is a subclass whose access gives "trylid-root-object" -- that allows its own .k file to work before Main is set up.

I still kinda want to make Main special...

"true" and "false" may present problems, but I should probably wait to see if they do before trying to fix them.  If they do, perhaps fake values can be used temporarily until Standard Bool is loaded.

In trylid.k, this is all put together in (load-trylid).


=====

Jolt's "break" Is Broken
	[2007.3.30]

It's the "break" statement that's breaking things right now ("cannot reduce 34675(#nil Block ---) to VOID") (in jolt-burg, anyway).


=====

Primitive Data
	[2007.3.31]

A single "PrimitiveWord" type can handle all operations, and be specially handled by the compiler.

Operations:
	+ - * / % & | &
	int-obj int-at: byte-at: long-at: obj-at:
	int-at:put: (etc.)

Shared fields:
	int-size (etc.)


=====

Timing
	[2007.4.22]

Always thru trylid-proto:  1:45.
"Quicker" (byte-ptr):      1:47. (!)
"Quicker" (trylid-int):    1.24.
"Quicker" (trylid-char):   0:58.
"Quicker" (trylid-string): 1.00.

At this point, the Trylid compiler loads itself (mostly; it did so completely recently, but not at the moment) but doesn't do codegen.  It became obvious that the generated Jolt code is much slower than Trylon's generated C, by about an order of magnitude.  My first theory was that (trylid-proto) might be the cause.  And it turned out that it was called surprisingly often: 7,636,346 times.  An attempt to eliminate its use for proto access failed due to dependency issues (I forget the details), so I tried just optimizing the primitives, as seen above.

I'm thinking this can be fixed in the general case by having a proto set up auto-loading stubs for its subprotos early in its loading process.  The stub would replace itself with the real proto-returner (via (add-shared-field-to)).


=====


