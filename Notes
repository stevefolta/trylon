[2007.3.4]

Go for fully dynamic:  A special dispatch provides for lazy loading of member protos.  A ProtoBuilder greedily reads the source(s), then builds the proto (now that it knows the number of ivars), then compiles the methods.  That means the methods are grabbed as text, and the parser can know at the time of parse-primary whether it needs to auto-declare.

Trylon objects get a special vtable that also checks (and knows) the enclosing context.

Just use "arg"/"args" for lambdas:

	collection each:
		arg item
		item println


=====

[2007.3.21]

Equals-block should make a new object, not a dict literal:

	trylid List
	fields head last

	create
		head = last = nil
	
	append: new-value
		new-cell = Cell new: value
		if last
			last tail = new-cell
		else
			head = new-cell
		last = new-cell

	Cell =
		fields head tail

		create: value
			head = value

But that should still serve the dict-literal purpose (and even better: 'dict entry' vs. 'dict at: "entry"').


=====

[2007.3.23]

All fields supporting the use of protos as packages (subproto names, ".parent-context", etc.) should be shared fields.

Will need:
	.proto
	.proto-name
	.parent-context


=====

Loading
	[2007.3.25]

Standard Object must be loaded first, and can't join Standard until later.  Use a (namespace ...) function instead of sends to access parent namespaces, and don't specify Main in its arguments -- (namespace Standard), (namespace Standard Implementation).  It will dynamically check to see if the namespace is loaded and load it from the .k file if not.  Or call it (load-trylid-proto), or just (trylid-proto).  So something like this:

	(define trylid-root-object (read-trylid-proto-file "Standard Object.k"))
	(setup-Main)
	(read-trylid-proto-file "Main.k")
		;; Should result in everything else getting loaded.

Standard Object is a subclass whose access gives "trylid-root-object" -- that allows its own .k file to work before Main is set up.

I still kinda want to make Main special...


=====


