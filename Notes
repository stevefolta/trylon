[2007.3.4]

Go for fully dynamic:  A special dispatch provides for lazy loading of member protos.  A ProtoBuilder greedily reads the source(s), then builds the proto (now that it knows the number of ivars), then compiles the methods.  That means the methods are grabbed as text, and the parser can know at the time of parse-primary whether it needs to auto-declare.

Trylon objects get a special vtable that also checks (and knows) the enclosing context.

Just use "arg"/"args" for lambdas:

	collection each:
		arg item
		item println


=====

[2007.3.21]

Equals-block should make a new object, not a dict literal:

	trylid List
	fields head last

	create
		head = last = nil
	
	append: new-value
		new-cell = Cell new: value
		if last
			last tail = new-cell
		else
			head = new-cell
		last = new-cell

	Cell =
		fields head tail

		create: value
			head = value

But that should still serve the dict-literal purpose (and even better: 'dict entry' vs. 'dict at: "entry"').

