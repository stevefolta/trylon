Class: CompiledClass
Superclass: Package

// Because this is really just like a Package, but with instance functions and
// fields, we make it a subclass of Package.


instance-functions: Dictionary of TrylonInstanceFunction;
instance-fields: List of CompiledField;
subclasses: List of CompiledClass;
superclass: CompiledClass;
class-num: Int;


create(name: String, parent: Package)
{
	super.create(name, parent);
	instance-functions = new Dictionary of TrylonInstanceFunction;
	instance-fields = new List of CompiledField;
	subclasses = new List of CompiledClass;
}


make-subclass-of(superclass: CompiledClass)
{
	if (this.superclass) {
		// Already had a superclass (perhaps the default Standard Object);
		// replace it.
		this.superclass.subclasses.remove(this);
		uses-packages.remove(this.superclass);
		}

	// Install the superclass.
	this.superclass = superclass;
	superclass.subclasses.append(this);

	// Automatically "use" the superclass.
	uses-packages.append(superclass);
}


add-instance-function(name: String, function: TrylonInstanceFunction)
{
	instance-functions[name] = function;

	TrylonCompiler.the-compiler.add-object-function(name);
	if (function.is-primitive)
		has-primitives = true;

	if (function.is-a(CompiledFunction) &&
	    (name == "create" || name.starts-with("create:"))) {
		// Add the corresponding "new" function.
		new-function: NewFunction(function.as-a(CompiledFunction), this);
		functions[new-function.name] = new-function;
		}
}


add-instance-field(field: CompiledField)
{
	instance-fields.append(field);
	add-instance-function(field.name, new InstanceFieldGetter(field, this));
	add-instance-function(field.name + ":",
	                      new InstanceFieldSetter(field, this));
}


lookup-instance-function(name: String): TrylonFunction
{
	function: TrylonFunction = instance-functions[name];
	if (function)
		return function;

	if (superclass)
		return superclass.lookup-instance-function(name);

	return nil;
}


has-instance-function(name: String): Bool
{
	return (instance-functions[name] != nil);
}


ensure-superclasses(object-class: CompiledClass)
{
	if (superclass == nil && this != object-class)
		this.make-subclass-of(object-class);

	super.ensure-superclasses(object-class);
}


emit-c-file(): Bool
{
	file: File = new File(".c-sources/" + c-name + ".c");
	stream: ExistingFileStream = new ExistingFileStream(file);

	//---
	if (lookup-function("verbose")) {
		reporter.report(name + " has these instance functions:");
		reporter.indent();
		for (name: String in instance-functions.keys)
			reporter.report(name + " (" + instance-functions[name].class.name + ")");
		reporter.unindent();
		}
	//---

	// Header, includes
	stream.write-line("/* " + c-name + ".c */");
	stream.write-line();
	stream.write-line("#include \"Trylon_.h\"");
	stream.write-line();

	// Class object
	superclass-ref: String = nil;
	if (superclass) {
		stream.write-line("extern class_spec_ " + superclass.c-name + ";");
		superclass-ref = "(obj_) &" + superclass.c-name;
		}
	else
		superclass-ref = "NULL";
	stream.write("DefineClassObj_(");
	stream.write(c-name);
	stream.write(", \"");
	stream.write(name);
	stream.write("\", ");
	stream.write(name.length.string);
	stream.write(", ");
	stream.write(superclass-ref);
	stream.write(", ");
	stream.write(total-instance-fields.string);
	stream.write(", ");
	stream.write(class-num.string);
	stream.write-line(")");
	stream.write("\n\n");

	// Instance field indices
	emit-instance-field-indices(stream);

	// Functions
	for (function: TrylonFunction in functions.values)
		function.emit-code(stream);
	for (function: TrylonFunction in instance-functions.values)
		function.emit-code(stream);

	is-changed: Bool = stream.is-changed;
	stream.close();
	return is-changed;
}


emit-all-class-declarations(stream: OutputStream)
{
	stream.write("extern class_spec_ ");
	stream.write(c-name);
	stream.write-line(";");

	for (subclass: CompiledClass in subclasses)
		subclass.emit-all-class-declarations(stream);
}


get-dispatch-entries(name: String, inherited-function: TrylonInstanceFunction,
                     dispatch-entries: DispatchEntries)
{
	function: TrylonInstanceFunction = instance-functions[name];
	if (function)
		dispatch-entries.functions.append(function);
	else
		function = inherited-function;
	if (function)
		dispatch-entries.entries.append(new DispatchEntry(this, function));

	// Have the subclasses write their entries
	for (subclass: CompiledClass in subclasses)
		subclass.get-dispatch-entries(name, function, dispatch-entries);
}


get-Object-dispatch-entries(name: String, dispatch-entries: DispatchEntries)
{
	// Like get-dispatch-entries, but only used for Object.

	// Have all subclasses go first.
	for (subclass: CompiledClass in subclasses)
		subclass.get-dispatch-entries(name, nil, dispatch-entries);

	// Add the our entry
	function: TrylonInstanceFunction = instance-functions[name];
	if (function)
		dispatch-entries.functions.append(function);
	dispatch-entries.object-function = function;
}


number-classes(numberer: ClassNumberer)
{
	// Depth-first.
	for (subclass: CompiledClass in subclasses)
		subclass.number-classes(numberer);

	class-num = numberer.next-number();
}


setup-dispatch-row(row: DispatchRow, inherited-function: TrylonInstanceFunction)
{
	// Find the function.
	function: TrylonInstanceFunction = instance-functions[row.name];
	if (function == nil)
		function = inherited-function;

	// Do this is depth-first order, which is the same order as the class
	// numbers.  By doing that, we don't need a separate step for sorting
	// by class number.

	for (subclass: CompiledClass in subclasses)
		subclass.setup-dispatch-row(row, function);

	if (function)
		row.append(class-num, function);
}


emit-instance-field-indices(stream: OutputStream): Int
{
	index: Int = 0;
	if (superclass)
		index = superclass.emit-instance-field-indices(stream);

	for (field: CompiledField in instance-fields) {
		stream.write("#define ");
		stream.write(MethodBuilder.mangle-name(field.name));
		stream.write("__fld_\t(");
		stream.write(index.string);
		index += 1;
		stream.write-line(")");
		}

	stream.write-line();

	return index;
}



total-instance-fields: Int
{
	total: Int = instance-fields.count;
	if (superclass)
		total += superclass.total-instance-fields;
	return total;
}


