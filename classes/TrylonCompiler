Class: TrylonCompiler
Superclass: Program


arguments: List of String;
successful: Bool;
object-function-names: Dictionary of String;
symbols: Dictionary of SymbolLiteral;
package-queue: List of Package;

// Build settings
program-name: String;
c-flags: List of String;
link-flags: List of String;
c-compiler: String;
linker: String;
is-verbose: Bool;

the-compiler: TrylonCompiler; 	[class]
status-reporter: StatusReporter; 	[class]



// Program

create(arguments: List of String)
{
	this.arguments = arguments;
	this.successful = true;
	object-function-names = new Dictionary of String;
	symbols = new Dictionary of SymbolLiteral;
	package-queue = new List of Package;

	program-name = "program-binary";
	c-flags = new List of String;
	link-flags = new List of String;
	c-compiler = "gcc";
	linker = "gcc";

	the-compiler = this;
}


run()
{
	try {
		// read the settings
		load-build-settings("build-settings.local");
		load-build-settings("build-settings");

		// parse the arguments
		file-names: List of String;
		compile-symbols: List of String;
		do-lex-test: Bool = false;
		for (arg: String in arguments.tail) {
			if (arg.starts-with("--")) {
				compile-symbols.append(arg.substr(2));
				if (arg == "--lex-test")
					do-lex-test = true;
				else if (arg == "--verbose") {
					status-reporter = new StdoutStatusReporter();
					is-verbose = true;
					}
				}
			else
				file-names.append(arg);
			}

		if (status-reporter == nil)
			status-reporter = new VT100StatusReporter();

		if (do-lex-test) {
			for (arg: String in arguments.tail.tail)
				lex-test(arg);
			}

		else {
			compile-program(compile-symbols);
			}
		}
	catch (e: Exception) {
		(e.message + "\n").write();
		successful = false;
		}
}


return-value: Int
{
	if (!successful)
		return 1;
	return 0;
}



// Top-level compilation

load-build-settings(file-name: String)
{
	file: File(file-name);
	if (!file.exists)
		return;

	parser: QuickParser(file.contents);
	while (!parser.is-done) {
		token: String = parser.next-token;
		if (token == "program")
			program-name = parser.next-token;
		else if (token == "c-flags") {
			loop {
				token = parser.next-token;
				if (token.is-empty)
					break;
				c-flags.append(token);
				}
			}
		else if (token == "link-flags") {
			loop {
				token = parser.next-token;
				if (token.is-empty)
					break;
				link-flags.append(token);
				}
			}
		else if (token == "c-compiler")
			c-compiler = parser.next-token;
		else if (token == "linker")
			linker = parser.next-token;

		parser.advance-line();
		}
}


compile-program(compile-symbols: List of String)
{
	// Create the .c-sources and .objects directories.
	directory: FileDirectory(".");
	if (!directory.entry-is-directory(".c-sources"))
		directory.create-subdirectory(".c-sources");
	if (!directory.entry-is-directory(".objects"))
		directory.create-subdirectory(".objects");

	// We need "destroy" to be a function name, even if there are no
	// functions with that name.
	add-object-function("destroy");

	// Load
	main-directory: FileDirectory(".");
	if (main-directory.entry-is-directory("sources"))
		main-directory = main-directory["sources"].as-a(FileDirectory);
	trylon-base-path: String =
		System.system.environment-variable("TRYLON_BASE");
	if (trylon-base-path == nil || trylon-base-path.is-empty)
		throw MessageException("TRYLON_BASE is not set!");
	library-directory: FileDirectory(trylon-base-path);
	status-reporter.report("Loading Main...");
	status-reporter.indent();
	main-package: Package("Main", nil);
	main-package.setup-main(main-directory, library-directory, compile-symbols);
	package-queue.append(main-package);
	status-reporter.unindent();

	// Make every class without a superclass be a subclass of Standard Object.
	main-package.ensure-superclasses(root-class(main-package));

	// Emit the classes and packages.
	status-reporter.report("Emitting code...");
	status-reporter.indent();
	compile-file-names: List of String;
	link-file-names: List of String;
	for (package: Package in package-queue) {
		is-changed: Bool = package.emit-code();
		file-name: String = package.c-name;
		if (is-changed)
			compile-file-names.append(file-name);
		link-file-names.append(file-name);
		}
	status-reporter.unindent();

	// Another round of ensure-superclasses, to get classes loaded during
	// the emit.
	main-package.ensure-superclasses(root-class(main-package));

	// Emit the method specs.
	status-reporter.report("Emitting method specs...");
	is-changed: Bool = emit-method-specs(main-package);
	if (is-changed)
		compile-file-names.append("methods_");
	link-file-names.append("methods_");

	// Emit the symbols.
	status-reporter.report("Emitting symbols...");
	is-changed = emit-symbols();
	if (is-changed)
		compile-file-names.append("symbols_");
	link-file-names.append("symbols_");

	// Copy Trylon_.h and Trylon_.c
	if (!library-directory.entry-is-directory("runtime")) {
		message: String = "The \"runtime\" directory is missing from the library!";
		throw MessageException(message);
		}
	runtime-directory: FileDirectory =
		library-directory["runtime"].as-a(FileDirectory);
	copy-to-sources(runtime-directory["Trylon_.h"].as-a(File), "Trylon_.h");
	is-changed =
		copy-to-sources(runtime-directory["Trylon_.c"].as-a(File), "Trylon_.c");
	if (is-changed)
		compile-file-names.append("Trylon_");
	link-file-names.append("Trylon_");

	// Copy primitives files
	main-package.copy-primitives-files(compile-file-names, link-file-names);


	// Compile C files.
	status-reporter.report("Compiling C files...");
	status-reporter.indent();
	for (file-name: String in compile-file-names) {
		status-reporter.report("Compiling " + file-name + ".c...");
		args: List of String;
		args.append("-c");
		args.append(".c-sources/" + file-name + ".c");
		args.append("-o");
		args.append(".objects/" + file-name + ".o");
		for (flag: String in c-flags)
			args.append(flag);
		report-run-program(c-compiler, args);
		status: Int = System.system.run-program(c-compiler, args);
		if (status != 0)
			throw MessageException("C compilation failed.");
		}
	status-reporter.unindent();

	// Link.
	status-reporter.report("Linking...");
	args: List of String;
	args.append("-o");
	args.append(program-name);
	for (flag: String in link-flags)
		args.append(flag);
	for (file-name: String in link-file-names)
		args.append(".objects/" + file-name + ".o");
	report-run-program(linker, args);
	System.system.run-program(linker, args);
}


add-object-function(name: String)
{
	object-function-names[name] = name;
}


get-symbol-literal(name: String): SymbolLiteral
{
	// Is it already there?
	symbol: SymbolLiteral = symbols[name];
	if (symbol)
		return symbol;

	// If not, we need to add it.
	symbol = new SymbolLiteral(name);
	symbols[name] = symbol;
	return symbol;
}


emit-method-specs(main-package: Package): Bool
{
	stream: ExistingFileStream(new File(".c-sources/methods_.c"));
	stream.write-line("#include \"Trylon_.h\"");
	stream.write-line();

	object-class: CompiledClass = root-class(main-package);

	// Declare the classes
	object-class.emit-all-class-declarations(stream);
	stream.write-line();

	// Write the dispatch tables
	for (fn-name: String in object-function-names.keys) {
		// Get the entries
		entries: DispatchEntries;
		object-class.get-Object-dispatch-entries(fn-name, entries);

		// Emit the declarations
		for (function: TrylonInstanceFunction in entries.functions) {
			stream.write("extern ");
			stream.write(function.c-signature);
			stream.write-line(";");
			}

		// Emit the dispatch table
		stream.write("MethodSpec_ ");
		stream.write(MethodBuilder.mangle-name(fn-name));
		stream.write-line("__methods[] = {");

		// Non-object entries
		for (entry: DispatchEntry in entries.entries) {
			stream.write("\t{ (obj_) &");
			stream.write(entry.for-class.c-name);
			stream.write(", ");
			stream.write(entry.function.c-name);
			stream.write(" },");
			stream.write-line();
			}

		// Object entry
		stream.write("\t{ NULL, ");
		if (entries.object-function)
			stream.write(entries.object-function.c-name);
		else
			stream.write("NULL");
		stream.write(" }");

		// Finish the dispatch table
		stream.write-line(" };");
		stream.write-line();
		}

	is-changed: Bool = stream.is-changed;
	stream.close();
	return is-changed;
}


emit-symbols(): Bool
{
	stream: ExistingFileStream(new File(".c-sources/symbols_.c"));
	stream.write-line("#include \"Trylon_.h\"");
	stream.write-line();

	for (symbol: SymbolLiteral in symbols.values) {
		stream.write("DefineSymbol_(");
		stream.write(MethodBuilder.mangle-name(symbol.name));
		stream.write(", \"");
		stream.write(symbol.name);
		stream.write("\", ");
		stream.write(MethodBuilder.string-literal-length(symbol.name).string);
		stream.write-line(")");
		}

	is-changed: Bool = stream.is-changed;
	stream.close();
	return is-changed;
}


root-class(main-package: Package): CompiledClass
{
	// Find "Standard Object"
	standard-package: Package = main-package.get-subpackage("Standard");
	if (standard-package == nil)
		throw MessageException("Standard package is missing!");
	object-function: TrylonFunction = standard-package.lookup-function("Object");
	if (object-function == nil)
		throw MessageException("Standard Object is missing!");
	if (!object-function.is-a(ClassFunction))
		throw MessageException("Standard Object is not a class!");
	return object-function.as-a(ClassFunction).the-class;
}


copy-to-sources(file: File, dest-name: String): Bool
{
	contents: String = file.contents;
	dest-file: File(".c-sources/" + dest-name);
	stream: ExistingFileStream(dest-file);
	stream.write(contents);
	is-changed: Bool = stream.is-changed;
	stream.close();
	return is-changed;
}


report-run-program(program: String, args: List of String)
{
	if (is-verbose) {
		status-reporter.indent();

		command: StringBuilder;
		command += program;
		command += " ";
		for (arg: String in args) {
			command += arg;
			command += " ";
			}
		status-reporter.report(command.string);

		status-reporter.unindent();
		}
}



// Test


lex-test(filename: String)
{
	try {
		lexer: Lexer(new File(filename).contents);
		loop {
			token: Token = lexer.next-token();
			token.type.write();
			if (token.text && !token.text.is-empty) {
				": ".write();
				token.text.write();
				}
			"\n".write();
			if (token.type == 'eof')
				break;
			}
		}
	catch (e: Exception) {
		"Error: ".write();
		e.message.write();
		"\n".write();
		}
}



