Class: TrylonCompiler
Superclass: Program


arguments: List of String;
successful: Bool;
build-settings: BuildSettings;
object-function-names: Dictionary of String;
symbols: Dictionary of SymbolLiteral;
character-literals: Dictionary of CharacterLiteral;
package-queue: List of Package;

the-compiler: TrylonCompiler; 	[class]
status-reporter: StatusReporter; 	[class]



// Program

create(arguments: List of String)
{
	this.arguments = arguments;
	this.successful = true;
	this.build-settings = new BuildSettings;
	object-function-names = new Dictionary of String;
	symbols = new Dictionary of SymbolLiteral;
	character-literals = new Dictionary of CharacterLiteral;
	package-queue = new List of Package;

	the-compiler = this;
}


run()
{
	try {
		// read the settings
		build-settings.load();

		// parse the arguments
		file-names: List of String;
		compile-symbols: List of String;
		do-lex-test: Bool = false;
		for (arg: String in arguments.tail) {
			if (arg.starts-with("--")) {
				compile-symbols.append(arg.substr(2));
				if (arg == "--lex-test")
					do-lex-test = true;
				else if (arg == "--verbose") {
					status-reporter = new StdoutStatusReporter();
					build-settings.is-verbose = true;
					}
				}
			else
				file-names.append(arg);
			}

		if (status-reporter == nil)
			status-reporter = new VT100StatusReporter();

		if (do-lex-test) {
			for (arg: String in arguments.tail.tail)
				lex-test(arg);
			}

		else {
			compile-program(compile-symbols);
			}
		}
	catch (e: Exception) {
		(e.message + "\n").write();
		successful = false;
		}
}


return-value: Int
{
	if (!successful)
		return 1;
	return 0;
}



// Top-level compilation

compile-program(compile-symbols: List of String)
{
	// Create the .c-sources and .objects directories.
	directory: FileDirectory(".");
	if (!directory.entry-is-directory(".c-sources"))
		directory.create-subdirectory(".c-sources");
	if (!directory.entry-is-directory(".objects"))
		directory.create-subdirectory(".objects");

	// We need "destroy" to be a function name, even if there are no
	// functions with that name.
	add-object-function("destroy");

	// Load
	main-directory: FileDirectory(".");
	if (main-directory.entry-is-directory("sources"))
		main-directory = main-directory["sources"].as-a(FileDirectory);
	trylon-base-path: String =
		System.system.environment-variable("TRYLON_BASE");
	if (trylon-base-path == nil || trylon-base-path.is-empty)
		throw MessageException("TRYLON_BASE is not set!");
	library-directory: FileDirectory(trylon-base-path);
	status-reporter.report("Loading Main...");
	status-reporter.indent();
	main-package: Package("Main", nil);
	main-package.setup-main(main-directory, library-directory, compile-symbols);
	package-queue.append(main-package);
	status-reporter.unindent();

	// Get ready to emit (mainly this makes sure all used classes are loaded).
	status-reporter.report("Preparing to emit...");
	status-reporter.indent();
	for (package: Package in package-queue)
		package.prepare-to-emit();
	status-reporter.unindent();

	// Make every class without a superclass be a subclass of Standard Object.
	object-class: CompiledClass = root-class(main-package);
	main-package.ensure-superclasses(object-class);

	// If we need to number the classes, now is the time to do it.
	if (!build-settings.slow-dispatch)
		object-class.number-classes(new ClassNumberer());

	// Emit the classes and packages.
	status-reporter.report("Emitting code...");
	status-reporter.indent();
	c-files: CFiles();
	for (package: Package in package-queue) {
		is-changed: Bool = package.emit-code();
		c-files.add(package.c-name, is-changed);
		}
	status-reporter.unindent();

	// Another round of ensure-superclasses, to get classes loaded during
	// the emit.
	main-package.ensure-superclasses(object-class);

	// Emit the method specs.
	is-changed: Bool;
	if (build-settings.slow-dispatch) {
		status-reporter.report("Emitting method specs...");
		is-changed = emit-method-specs(main-package);
		}
	else {
		is-changed = emit-dispatch-table(main-package);
		}
	c-files.add("methods_", is-changed);

	// Emit the symbols.
	status-reporter.report("Emitting symbols...");
	is-changed = emit-symbols();
	c-files.add("symbols_", is-changed);

	// Emit settings_.h.
	is-changed = emit-settings();
	recompile-all: Bool = is-changed;

	// Copy Trylon_.h and Trylon_.c
	if (!library-directory.entry-is-directory("runtime")) {
		message: String = "The \"runtime\" directory is missing from the library!";
		throw MessageException(message);
		}
	runtime-directory: FileDirectory =
		library-directory["runtime"].as-a(FileDirectory);
	is-changed =
		copy-to-sources(runtime-directory["Trylon_.h"].as-a(File), "Trylon_.h");
	if (is-changed)
		recompile-all = true;
	is-changed =
		copy-to-sources(runtime-directory["Trylon_.c"].as-a(File), "Trylon_.c");
	c-files.add("Trylon_", is-changed);

	// Copy primitives files
	main-package.copy-primitives-files(c-files);


	// Compile C files.
	status-reporter.report("Compiling C files...");
	status-reporter.indent();
	for (c-file: CFile in c-files) {
		if (!c-file.is-changed && !recompile-all) {
			if (new File(".objects/" + c-file.name + ".o").exists)
				continue;
			}

		file-name: String = c-file.name;
		status-reporter.report("Compiling " + file-name + ".c...");
		args: List of String;
		args.append("-c");
		args.append(".c-sources/" + file-name + ".c");
		args.append("-o");
		args.append(".objects/" + file-name + ".o");
		for (flag: String in build-settings.c-flags)
			args.append(flag);
		report-run-program(build-settings.c-compiler, args);
		status: Int = System.system.run-program(build-settings.c-compiler, args);
		if (status != 0)
			throw MessageException("C compilation failed.");
		}
	status-reporter.unindent();

	// Link.
	status-reporter.report("Linking...");
	args: List of String;
	args.append("-o");
	args.append(build-settings.program-name);
	for (c-file: CFile in c-files)
		args.append(".objects/" + c-file.name + ".o");
	for (flag: String in build-settings.link-flags)
		args.append(flag);
	report-run-program(build-settings.linker, args);
	System.system.run-program(build-settings.linker, args);
}


add-object-function(name: String)
{
	object-function-names[name] = name;
}


get-symbol-literal(name: String): SymbolLiteral
{
	// Is it already there?
	symbol: SymbolLiteral = symbols[name];
	if (symbol)
		return symbol;

	// If not, we need to add it.
	symbol = new SymbolLiteral(name);
	symbols[name] = symbol;
	return symbol;
}


get-character-literal(name: String): CharacterLiteral
{
	// Is it already there?
	name = Lexer.character-constant-value(name).string;
	literal: CharacterLiteral = character-literals[name];
	if (literal)
		return literal;

	// If not, we need to add it.
	literal = new CharacterLiteral(name);
	character-literals[name] = literal;
	return literal;
}


emit-method-specs(main-package: Package): Bool
{
	stream: ExistingFileStream(new File(".c-sources/methods_.c"));
	stream.write-line("#include \"Trylon_.h\"");
	stream.write-line();

	object-class: CompiledClass = root-class(main-package);

	// Declare the classes
	object-class.emit-all-class-declarations(stream);
	stream.write-line();

	// Write the dispatch tables
	for (fn-name: String in object-function-names.keys) {
		// Get the entries
		entries: DispatchEntries;
		object-class.get-Object-dispatch-entries(fn-name, entries);

		// Emit the declarations
		for (function: TrylonInstanceFunction in entries.functions) {
			stream.write("extern ");
			stream.write(function.c-signature);
			stream.write-line(";");
			}

		// Emit the dispatch table
		stream.write("MethodSpec_ ");
		stream.write(MethodBuilder.mangle-name(fn-name));
		stream.write-line("__methods[] = {");

		// Non-object entries
		for (entry: DispatchEntry in entries.entries) {
			stream.write("\t{ (obj_) &");
			stream.write(entry.for-class.c-name);
			stream.write(", ");
			stream.write(entry.function.c-name);
			stream.write(" },");
			stream.write-line();
			}

		// Object entry
		stream.write("\t{ NULL, ");
		if (entries.object-function)
			stream.write(entries.object-function.c-name);
		else
			stream.write("NULL");
		stream.write(" }");

		// Finish the dispatch table
		stream.write-line(" };");
		stream.write-line();
		}

	is-changed: Bool = stream.is-changed;
	stream.close();
	return is-changed;
}


emit-dispatch-table(main-package: Package): Bool
{
	status-reporter.report("Building dispatch table...");
	if (build-settings.is-verbose)
		status-reporter.indent();

	object-class: CompiledClass = root-class(main-package);

	// Gather up the rows.
	rows: DispatchRowSet;
	for (fn-name: String in object-function-names.keys) {
		// Create the row and fill it in.
		row: DispatchRow(fn-name);
		object-class.setup-dispatch-row(row, nil);

		// Add the row.
		rows.add(row);
		}

	// Fit the rows.
	// "rows" has the rows sorted by number of entries.
	dispatch-table: ExpandoArray of DispatchTableEntry;
	used-offsets: ExpandoBitmap;
	for (row: DispatchRow in rows) {
		if (build-settings.is-verbose)
			status-reporter.report("Fitting " + row.name + "...");
		row.fit-into(dispatch-table, used-offsets);
		}

	if (build-settings.is-verbose)
		status-reporter.unindent();

	// Now, emit the "methods_.c" file.
	status-reporter.report("Emitting dispatch table...");

	// Create the file.
	stream: ExistingFileStream(new File(".c-sources/methods_.c"));
	stream.write-line("#include \"Trylon_.h\"");
	stream.write-line();

	// Define all selectors.
	for (row: DispatchRow in rows) {
		stream.write("DefineSelector_(");
		stream.write(MethodBuilder.mangle-name(row.name));
		stream.write(", ");
		stream.write(row.selector.string);
		stream.write(")");
		stream.write-line();
		}
	stream.write-line();

	// Declare all functions.
	object-class.emit-all-instance-function-declarations(stream);
	stream.write-line();

	// Emit the dispatch table.
	stream.write-line("struct RDTableEntry_ dispatchTable_[] = {");
	for (entry: DispatchTableEntry in dispatch-table) {
		if (entry == nil) {
			stream.write-line("\t{ NULL, NULL },");
			continue;
			}

		stream.write("\t{ ");
		stream.write(entry.function.c-name);
		stream.write(", ");
		stream.write(entry.selector.string);
		stream.write(" },");
		stream.write-line();
		}
	stream.write-line("};");
	stream.write-line();

	is-changed: Bool = stream.is-changed;
	stream.close();
	return is-changed;
}


emit-symbols(): Bool
{
	// Character literals are also emitted here.

	stream: ExistingFileStream(new File(".c-sources/symbols_.c"));
	stream.write-line("#include \"Trylon_.h\"");
	stream.write-line();

	// Symbols.
	for (symbol: SymbolLiteral in symbols.values) {
		stream.write("DefineSymbol_(");
		stream.write(MethodBuilder.mangle-name(symbol.name));
		stream.write(", \"");
		stream.write(symbol.name);
		stream.write("\", ");
		stream.write(MethodBuilder.string-literal-length(symbol.name).string);
		stream.write-line(")");
		}
	stream.write-line();

	// Character literals.
	for (literal: CharacterLiteral in character-literals.values) {
		// The literal's name is a string of a decimal number which is the 
		// character's ASCII value.
		char: Int = literal.name.as-int;
		escaped-char: String = char.char-string;
		if (char < ' ' || char > '~' || char == '\'' || char == '\\') {
			escaped-char = "\\x";
			digit: Int = (char >> 4) & 0x0F;
			if (digit >= 0x0A && digit <= 0x0F)
				digit = digit - 0x0A + 'A';
			else
				digit = digit + '0';
			escaped-char += digit.char-string;
			digit = char & 0x0F;
			if (digit >= 0x0A && digit <= 0x0F)
				digit = digit - 0x0A + 'A';
			else
				digit = digit + '0';
			escaped-char += digit.char-string;
			}

		stream.write("DefineChar_(");
		stream.write(MethodBuilder.mangle-name(literal.name));
		stream.write(", \'");
		stream.write(escaped-char);
		stream.write-line("\')");
		}
	stream.write-line();

	is-changed: Bool = stream.is-changed;
	stream.close();
	return is-changed;
}


emit-settings(): Bool
{
	stream: ExistingFileStream(new File(".c-sources/settings_.h"));

	if (build-settings.slow-dispatch)
		stream.write-line("#define SLOW_DISPATCH_");
	else
		stream.write-line("#define ROW_DISPLACEMENT_DISPATCH_");

	is-changed: Bool = stream.is-changed;
	stream.close();
	return is-changed;
}


root-class(main-package: Package): CompiledClass
{
	// Find "Standard Object"
	standard-package: Package = main-package.get-subpackage("Standard");
	if (standard-package == nil)
		throw MessageException("Standard package is missing!");
	object-function: TrylonFunction = standard-package.lookup-function("Object");
	if (object-function == nil)
		throw MessageException("Standard Object is missing!");
	if (!object-function.is-a(ClassFunction))
		throw MessageException("Standard Object is not a class!");
	return object-function.as-a(ClassFunction).the-class;
}


copy-to-sources(file: File, dest-name: String): Bool
{
	contents: String = file.contents;
	dest-file: File(".c-sources/" + dest-name);
	stream: ExistingFileStream(dest-file);
	stream.write(contents);
	is-changed: Bool = stream.is-changed;
	stream.close();
	return is-changed;
}


report-run-program(program: String, args: List of String)
{
	if (build-settings.is-verbose) {
		status-reporter.indent();

		command: StringBuilder;
		command += program;
		command += " ";
		for (arg: String in args) {
			command += arg;
			command += " ";
			}
		status-reporter.report(command.string);

		status-reporter.unindent();
		}
}



// Test


lex-test(filename: String)
{
	try {
		lexer: Lexer(new File(filename).contents);
		loop {
			token: Token = lexer.next-token();
			token.type.write();
			if (token.text && !token.text.is-empty) {
				": ".write();
				token.text.write();
				}
			"\n".write();
			if (token.type == 'eof')
				break;
			}
		}
	catch (e: Exception) {
		"Error: ".write();
		e.message.write();
		"\n".write();
		}
}



