Class: FunctionCall
Superclass: Expression

name: String;
arguments: List of Expression;
context: Context;
function: TrylonFunction; 	// Only valid after prepare-to-emit().


create(name: String, arguments: (List of Expression), context: Context)
{
	this.name = name;
	this.arguments = arguments;
	this.context = context;
}


prepare-to-emit()
{
	function = context.lookup-function(name);

	for (arg: Expression in arguments)
		arg.prepare-to-emit();
}


emit-code(builder: MethodBuilder): ExpressionResult
{
	// We already got the function in prepare-to-emit().
	if (function == nil) {
		//*** This should become an ObjectCall on "this" -- if there is a "this".
		throw MessageException("There is no \"" + name + "\" function.");
		}

	// Generate the arguments.
	arg-results: List of ExpressionResult;
	for (arg: Expression in arguments) {
		result: ExpressionResult = arg.emit-code(builder);
		arg-results.append(result);
		}

	return function.emit-call(arg-results, builder);
}


convert-to-setter-call(value: Expression)
{
	if (name.ends-with(":"))
		name += "set-to:";
	else
		name += ":";
	arguments.append(value);
}


copy: FunctionCall
{
	copied-args: List of Expression;
	for (arg: Expression in arguments)
		copied-args.append(arg);
	return new FunctionCall(name, copied-args, context);
}


function: TrylonFunction
{
	return context.lookup-function(name);
}


