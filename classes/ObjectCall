Class: ObjectCall
Superclass: Expression


name: String;
object: Expression;
arguments: List of Expression;

// Very special for prepare-to-emit() handling of class and package functions.
package-result-function: TrylonFunction;


create(name: String, object: Expression, arguments: List of Expression)
{
	this.name = name;
	this.object = object;
	this.arguments = arguments;
}


prepare-to-emit()
{
	object.prepare-to-emit();

	for (arg: Expression in arguments)
		arg.prepare-to-emit();

	// Handle class functions and package functions.
	function: TrylonFunction = nil;
	if (object.is-a(FunctionCall))
		function = object.as-a(FunctionCall).function;
	else if (object.is-a(ObjectCall))
		function = object.as-a(ObjectCall).package-result-function;
	if (function) {
		if (function.is-a(PackageFunction) || function.is-a(ClassFunction)) {
			package: Package = nil;
			if (function.is-a(PackageFunction))
				package = function.as-a(PackageFunction).package;
			else
				package = function.as-a(ClassFunction).the-class;
			package-result-function = package.lookup-function(name);
			}
		}
}


emit-code(builder: MethodBuilder): ExpressionResult
{
	// Emit the object.
	object-result: ExpressionResult = object.emit-code(builder);

	// Emit the arguments.
	arg-results: List of ExpressionResult;
	for (arg: Expression in arguments)
		arg-results.append(arg.emit-code(builder));

	// Handle class functions and package functions
	if (object-result.is-a(PackageResult) || object-result.is-a(ClassResult)) {
		package: Package = nil;
		if (object-result.is-a(PackageResult))
			package = object-result.as-a(PackageResult).package;
		else
			package = object-result.as-a(ClassResult).the-class;
		function: TrylonFunction = package.lookup-function(name);
		if (function)
			return function.emit-call(arg-results, builder);
		}

	// Emit the call.
	builder.using-object-function(name);
	temporary: Temporary = builder.get-temporary();
	line: String = temporary.name + " = ";
	line += "Call_(" + builder.mangle-name(name) + ", " + object-result.access;
	for (arg-result: ExpressionResult in arg-results)
		line += ", " + arg-result.access;
	line += ");";
	builder.add-line(line);
	return temporary;
}


convert-to-setter-call(value: Expression)
{
	if (name.ends-with(":"))
		name += "set-to:";
	else
		name += ":";
	arguments.append(value);
}


copy: ObjectCall
{
	copied-args: List of Expression;
	for (arg: Expression in arguments)
		copied-args.append(arg);
	return new ObjectCall(name, object, copied-args);
}


