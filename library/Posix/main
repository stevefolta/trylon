trylon Posix


# Errors.

c-fn errno
	return BuildInt_(errno);

c-fn strerror: errnum
	return BuildString_(strerror(IntValue_(errnum)));


# Files.

c-fn read-fd: fd to: buffer size: size
	return BuildInt_(read(IntValue_(fd), BytePtrValue_(buffer), IntValue_(size)));

c-fn write-fd: fd from: buffer size: size
	return BuildInt_(write(IntValue_(fd), BytePtrValue_(buffer), IntValue_(size)));

c-fn open: path int-flags: flags
	return BuildInt_(open(CString_(path), IntValue_(flags)));

open: path flags: flags
	int-flags = 0
	for flag in flags
		int-flags |= value-for-flag: flag
	return open: path int-flags: int-flags

c-fn close-fd: fd
	return BuildInt_(close(IntValue_(fd)));

c-fn lseek-fd: fd offset: offset whence: whence
	UsingSym_(SEEK_ul_CUR) UsingSym_(SEEK_ul_END) UsingSym_(SEEK_ul_SET)
	UsingSym_(current) UsingSym_(eof) UsingSym_(set)
	static const EnumDictEntry_ whenceDict[] = {
		{ Sym_(SEEK_ul_CUR), SEEK_CUR },
		{ Sym_(SEEK_ul_END), SEEK_END },
		{ Sym_(SEEK_ul_SET), SEEK_SET },
		{ Sym_(current), SEEK_CUR },
		{ Sym_(eof), SEEK_END },
		{ Sym_(set), SEEK_SET },
		};
	int whenceInt =
		SymToEnum_(whence, whenceDict, NumEnumsIn_(whenceDict), SEEK_SET);
	off_t result = lseek(IntValue_(fd), IntValue_(offset), whenceInt);
	return BuildInt_(result);

stdin-fd = 0
stdout-fd = 1
stderr-fd = 2

c-fn dup: old-fd
	int result = dup(IntValue_(old_fd));
	if (result < 0)
		throw_errno();
	return BuildInt_(result);

c-fn dup-from: old-fd to: new-fd
	int result = dup2(IntValue_(old_fd), IntValue_(new_fd));
	if (result < 0)
		throw_errno();
	return BuildInt_(result);


# Processes.

c-fn fork
	return BuildInt_(fork());

class WaitResult
	fields child status

	create: child status: status
		this child = child
		this status = status
	
	is-valid
		return child != -1

	c-fn exited
		int status = IntValue_(Field_(status));
		return Bool_(WIFEXITED(status));

	c-fn exit-status
		int status = IntValue_(Field_(status));
		return BuildInt_(WEXITSTATUS(status));
	
	c-fn signaled
		int status = IntValue_(Field_(status));
		return Bool_(WIFSIGNALED(status));
	
	c-fn termination-signal
		int status = IntValue_(Field_(status));
		return BuildInt_(WTERMSIG(status));
	
	c-fn stopped
		int status = IntValue_(Field_(status));
		return Bool_(WIFSTOPPED(status));
	
	c-fn stop-signal
		int status = IntValue_(Field_(status));
		return BuildInt_(WSTOPSIG(status));
	
	c-preamble
		#include <sys/types.h>
		#include <sys/wait.h>

c-fn wait-pid: pid options: options
	UsingSym_(no_hang) UsingSym_(untraced)
	UsingSym_(WNOHANG) UsingSym_(WUNTRACED)
	UsingClass_(WaitResult__Posix)
	UsingMethod_(new_co_status_co_)
	int optionsInt = 0;
	pid_t child;
	int status;
	obj_ result;
	static const EnumDictEntry_ optionDict[] = {
		{ Sym_(WNOHANG), WNOHANG },
		{ Sym_(WUNTRACED), WUNTRACED },
		{ Sym_(no_hang), WNOHANG },
		{ Sym_(untraced), WUNTRACED },
		};

	/* Gather the options. */
	optionsInt = BitFlagsFromSyms_(options, optionDict, NumEnumsIn_(optionDict));
	
	/* Call waitpid(). */
	child = waitpid(IntValue_(pid), &status, optionsInt);

	/* Build the result. */
	result = Call_(new_co_status_co_, Proto_(WaitResult__Posix), BuildInt_(child), BuildInt_(status));
	return result;

wait-pid: pid
	return wait-pid: pid options: nil

c-fn wait
	UsingClass_(WaitResult__Posix)
	UsingMethod_(new_co_status_co_)
	pid_t child;
	int status;
	obj_ result;
	
	/* Call wait(). */
	child = wait(&status);

	/* Build the result. */
	result = Call_(new_co_status_co_, Proto_(WaitResult__Posix), BuildInt_(child), BuildInt_(status));
	return result;

c-fn exit: status
	_exit(IntValue_(status));


# "exec" family.

c-fn exec: filename arguments: arguments environment: environment
	char** args = build_args_list(arguments);
	char** env = build_args_list(environment);
	execve(CString_(filename), args, env);
	throw_errno();

c-fn exec: path arguments: arguments
	execv(CString_(path), build_args_list(arguments));
	throw_errno();

c-fn execp: file arguments: arguments
	execvp(CString_(file), build_args_list(arguments));
	throw_errno();


# Pipes.

class PipeFDs
	fields read write

	create-read: read write: write
		this read = read
		this write = write

c-fn pipe
	int pipefds[2];
	int result;
	extern obj_ new_read_co_write_co___PipeFDs__Posix(obj_, obj_, obj_);
	UsingClass_(PipeFDs__Posix)

	result = pipe(pipefds);
	if (result < 0)
		throw_errno();

	return
		new_read_co_write_co___PipeFDs__Posix(
			Proto_(PipeFDs__Posix), BuildInt_(pipefds[0]), BuildInt_(pipefds[1]));


# Directories.

c-fn getcwd
	char* path = AllocNonPtr_(2048);
	char* result = getcwd(path, 2048);
	if (result == NULL)
		throw_errno();
	return BuildString_(path);

c-fn chdir: path
	if (chdir(CString_(path)) < 0)
		throw_errno();

c-fn fchdir: path
	if (fchdir(IntValue_(path)) < 0)
		throw_errno();


c-fn mkdir: path mode: mode
	if (mkdir(CString_(path), IntValue_(mode)) < 0)
		throw_errno();

c-fn rmdir: path
	if (rmdir(CString_(path)) < 0)
		throw_errno();


# Random.

c-fn rand
	return BuildInt_(rand());

c-fn srand: seed
	srand(IntValue_(seed));



# Private.

c-preamble
	#include <unistd.h>
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <fcntl.h>
	#include <errno.h>
	#include <string.h>
	#include <sys/wait.h>

	static void throw_errno()
	{
		extern obj_ new__ErrnoException__Posix();
		Throw_(new__ErrnoException__Posix());
	}

	static char** build_args_list(obj_ arguments)
	{
		UsingMethod_(num_items)
		int numArgs = IntValue_(Call_(num_items, arguments));
		char** args = (char**) Allocate_((numArgs + 1) * sizeof(char*));
		int argNum = 0;
		ForStart_(1, arguments, arg)
			args[argNum] = CString_(arg);
			argNum += 1;
			ForEnd_(1)
		args[argNum] = NULL;
		return args;
	}


c-fn value-for-flag: flag
	UsingSym_(O_ul_RDONLY)
	UsingSym_(O_ul_WRONLY)
	UsingSym_(O_ul_RDWR)
	UsingSym_(O_ul_APPEND)
	UsingSym_(O_ul_ASYNC)
	UsingSym_(O_ul_CREAT)
	UsingSym_(O_ul_DIRECT)
	UsingSym_(O_ul_DIRECTORY)
	UsingSym_(O_ul_EXCL)
	UsingSym_(O_ul_LARGEFILE)
	UsingSym_(O_ul_NOATIME)
	UsingSym_(O_ul_NOCTTY)
	UsingSym_(O_ul_NOFOLLOW)
	UsingSym_(O_ul_NONBLOCK)
	UsingSym_(O_ul_NDELAY)
	UsingSym_(O_ul_SYNC)
	UsingSym_(O_ul_TRUNC)

	static const EnumDictEntry_ flagsDict[] = {
		{ Sym_(O_ul_APPEND), O_APPEND },
		{ Sym_(O_ul_ASYNC), O_ASYNC },
		{ Sym_(O_ul_CREAT), O_CREAT },
		#ifdef __USE_GNU
			{ Sym_(O_ul_DIRECT), O_DIRECT },
			{ Sym_(O_ul_DIRECTORY), O_DIRECTORY },
		#endif
		{ Sym_(O_ul_EXCL), O_EXCL },
		#ifdef __USE_LARGEFILE64
			{ Sym_(O_ul_LARGEFILE), O_LARGEFILE },
		#endif
		{ Sym_(O_ul_NDELAY), O_NDELAY },
		#ifdef __USE_GNU
			{ Sym_(O_ul_NOATIME), O_NOATIME },
		#endif
		{ Sym_(O_ul_NOCTTY), O_NOCTTY },
		#ifdef __USE_GNU
			{ Sym_(O_ul_NOFOLLOW), O_NOFOLLOW },
		#endif
		{ Sym_(O_ul_NONBLOCK), O_NONBLOCK },
		{ Sym_(O_ul_RDONLY), O_RDONLY },
		{ Sym_(O_ul_RDWR), O_RDWR },
		{ Sym_(O_ul_SYNC), O_SYNC },
		{ Sym_(O_ul_TRUNC), O_TRUNC },
		{ Sym_(O_ul_WRONLY), O_WRONLY }
		};
	int intFlag =
		SymToEnum_(flag, flagsDict, sizeof(flagsDict) / sizeof(EnumDictEntry_), 0);
	return BuildInt_(intFlag);


class ErrnoException
	field errno

	create
		this errno = Posix errno
	
	message
		return strerror: errno


references
	'O_RDONLY'
	'O_WRONLY'
	'O_RDWR'
	'O_APPEND'
	'O_ASYNC'
	'O_CREAT'
	'O_DIRECT'
	'O_DIRECTORY'
	'O_EXCL'
	'O_LARGEFILE'
	'O_NOATIME'
	'O_NOCTTY'
	'O_NOFOLLOW'
	'O_NONBLOCK'
	'O_NDELAY'
	'O_SYNC'
	'O_TRUNC'

	'no-hang'
	'untraced'
	'WNOHANG'
	'WUNTRACED'

	'set'
	'current'
	'eof'
	'SEEK_SET'
	'SEEK_CUR'
	'SEEK_END'

