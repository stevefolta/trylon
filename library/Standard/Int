trylid Int

new
	return Implementation allocate-object: Int with-extra-slots: 1

fn == arg (Int) -> Bool
	coke
		(if (== (int@ self_) (int@ arg)) true false)
fn != arg (Int) -> Bool
	coke
		(if (!= (int@ self_) (int@ arg)) true false)
fn < arg (Int) -> Bool
	coke
		(if (< (int@ self_) (int@ arg)) true false)
fn > arg (Int) -> Bool
	coke
		(if (> (int@ self_) (int@ arg)) true false)
fn <= arg (Int) -> Bool
	coke
		(if (<= (int@ self_) (int@ arg)) true false)
fn >= arg (Int) -> Bool
	coke
		(if (>= (int@ self_) (int@ arg)) true false)

fn + arg (Int) -> Int
	coke
		(int-obj (+ (int@ self_) (int@ arg)))
fn - arg (Int) -> Int
	coke
		(int-obj (- (int@ self_) (int@ arg)))
fn * arg (Int) -> Int
	coke
		(int-obj (* (int@ self_) (int@ arg)))
fn / arg (Int) -> Int
	coke
		(int-obj (/ (int@ self_) (int@ arg)))
fn % arg (Int) -> Int
	coke
		(int-obj (% (int@ self_) (int@ arg)))
fn unary-minus -> Int
	coke
		(int-obj (- (int@ self_)))

fn | arg (Int) -> Int
	coke
		(int-obj (| (int@ self_) (int@ arg)))
fn & arg (Int) -> Int
	coke
		(int-obj (& (int@ self_) (int@ arg)))
fn ^ arg (Int) -> Int
	coke
		(int-obj (^ (int@ self_) (int@ arg)))
fn ~ -> Int
	coke
		(int-obj (not (int@ self_)))
fn << arg (Int) -> Int
	coke
		(int-obj (<< (int@ self_) (int@ arg)))
fn >> arg (Int) -> Int
	coke
		(int-obj (>> (int@ self_) (int@ arg)))

fn string -> String
	coke
		(let ((buf (malloc 64)))
			(sprintf buf "%d" (int@ self_))
			(string-obj buf))
fn float -> Float
	# How to do this?
	#...
fn char -> Char
	coke
		(char-obj (int@ self_))


iff debugger
	fn debug-write
		print-line: "Int: " + this string

