trylid Int

new
	return Implementation allocate-object: Int with-extra-slots: 1

fn == arg (Int) -> Bool
	coke
		(if (== (int@ self_) (int@ arg)) true false)
fn != arg (Int) -> Bool
	coke
		(if (!= (int@ self_) (int@ arg)) true false)
fn < arg (Int) -> Bool
	coke
		(if (< (int@ self_) (int@ arg)) true false)
fn > arg (Int) -> Bool
	coke
		(if (> (int@ self_) (int@ arg)) true false)
fn <= arg (Int) -> Bool
	coke
		(if (<= (int@ self_) (int@ arg)) true false)
fn >= arg (Int) -> Bool
	coke
		(if (>= (int@ self_) (int@ arg)) true false)

fn + arg (Int) -> Int
	coke
		(trylid-int (+ (int@ self_) (int@ arg)))
fn - arg (Int) -> Int
	coke
		(trylid-int (- (int@ self_) (int@ arg)))
fn * arg (Int) -> Int
	coke
		(trylid-int (* (int@ self_) (int@ arg)))
fn / arg (Int) -> Int
	coke
		(trylid-int (/ (int@ self_) (int@ arg)))
fn % arg (Int) -> Int
	coke
		(trylid-int (% (int@ self_) (int@ arg)))
fn unary-minus -> Int
	coke
		(trylid-int (- (int@ self_)))

fn | arg (Int) -> Int
	coke
		(trylid-int (| (int@ self_) (int@ arg)))
fn & arg (Int) -> Int
	coke
		(trylid-int (& (int@ self_) (int@ arg)))
fn ^ arg (Int) -> Int
	coke
		(trylid-int (^ (int@ self_) (int@ arg)))
fn ~ -> Int
	coke
		(trylid-int (not (int@ self_)))
fn << arg (Int) -> Int
	coke
		(trylid-int (<< (int@ self_) (int@ arg)))
fn >> arg (Int) -> Int
	coke
		(trylid-int (>> (int@ self_) (int@ arg)))

fn string
	coke
		(let ((buf (malloc 64)))
			(sprintf buf "%d" (int@ self_))
			(trylid-string buf))
fn float
	# How to do this?
	#...
fn char
	coke
		(trylid-char (int@ self_))


# In case we need to play nice with SmallIntegers:
_integerValue
	coke
		(int@ self_)
asInteger
	coke
		(send value_: SmallInteger (int@ self_))
value_: value_
	# Switch this to the SmallInteger version, maybe.
	new-int = Int new
	coke
		(set-int@ new-int value_)
	return new-int
	# SmallInteger version:
	# return SmallInteger value_: value_


iff debugger
	fn debug-write
		print-line: "Int: " + this string

