trylon MethodBuilder

fields code used-object-functions extern-declarations
fields next-temporary-num num-temporaries-used primitive-temporaries
fields string-literals next-string-literal-num
fields int-literals float-literals next-int-literal-num next-float-literal-num
fields dict-literals next-dict-literal-num
fields used-fields used-classes
fields indent-level


create
	code = StringBuilder new
	used-object-functions = Dictionary new
	extern-declarations = List new
	next-temporary-num = 0
	num-temporaries-used = 0
	next-string-literal-num = 0
	string-literals = List new
	next-int-literal-num = 0
	int-literals = List new
	next-float-literal-num = 0
	float-literals = List new
	dict-literals = List new
	next-dict-literal-num = 0
	used-fields = ObjectMap new
	used-classes = ObjectMap new
	indent-level = 0


get-temporary-of-type: type
	# Handle primitive types.
	## Using a Dictionary, instead of an ObjectDict (since there is no ObjectDict),
	## so for now only Standard should have primitive types.
	if type && type is-primitive
		if primitive-temporaries == nil
			primitive-temporaries = Dictionary new
		temp-num = primitive-temporaries at: type name
		if temp-num == nil
			temp-num = 0
		else
			temp-num = temp-num + 1
		(primitive-temporaries at: type name) = temp-num
		temp-name = "t" + type primitive-type-name + temp-num string + "_"
		return Temporary new: temp-name type: type

	# Standard temporary handling.
	temp-num = next-temporary-num
	next-temporary-num += 1
	if next-temporary-num > num-temporaries-used
		num-temporaries-used = next-temporary-num
	return Temporary new: "t" + temp-num string + "_" type: type

get-temporary
	return get-temporary-of-type: nil


add-string-literal: string-literal
	string-literal index = next-string-literal-num
	next-string-literal-num += 1
	string-literals append: string-literal


add-int-literal: int-literal
	int-literal index = next-int-literal-num
	next-int-literal-num += 1
	int-literals append: int-literal


add-float-literal: float-literal
	float-literal index = next-float-literal-num
	next-float-literal-num += 1
	float-literals append: float-literal


add-dict-literal: dict-literal
	dict-literal index = next-dict-literal-num
	next-dict-literal-num += 1
	dict-literals append: dict-literal


using-object-function: name
	used-object-functions at: name set-to: name


add-extern-declaration: declaration
	extern-declarations append: declaration


using-field: field on-package: on-package
	# This is a little tricky.  We count on the fact that we'll be given 
	# the same "field" object anytime that the field in "on-package" is 
	# referenced.  So we can use an ObjectMap to keep track of them.
	used-fields at: field set-to: on-package


using-class: the-class
	used-classes at: the-class set-to: the-class


add-line: line
	# Add the indent.
	adjusted-indent-level = indent-level
	if adjusted-indent-level > 20
		adjusted-indent-level = 20
	code += 	--
		"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t" 	--
			substr: 0 length: adjusted-indent-level
	
	code += line
	code += "\n"


add-blank-line
	code += "\n"


indent
	indent-level += 1


unindent
	indent-level -= 1


emit: stream
	stream write-line: "{"
	stream write-line: "\tint _broken_;"

	# Emit the string literals.
	for literal in string-literals
		stream write-all: 	--
			("\tDefineString_(", literal index string, ", \"", literal value, "\")")
		stream write-line
	
	# Emit the int literals.
	for literal in int-literals
		stream write-all: 	--
			("\tDefineInt_(", literal index string, ", ", literal value string, ")")
		stream write-line
	
	# Emit the float literals.
	for literal in float-literals
		stream write-all: 	--
			("\tDefineFloat_(", literal index string, ", ", 	--
			 literal value string, ")")
		stream write-line
	
	# Emit the dict literals.
	for literal in dict-literals
		literal emit-declaration: stream
	
	# Emit the temporary declarations.
	if num-temporaries-used > 0
		stream write: "\tobj_ "
		for temp-num in Interval new: num-temporaries-used
			if temp-num != 0
				stream write: ", "
			stream write-all: ("t", temp-num string, "_")
			temp-num += 1
		stream write-line: ";"
	
	# Emit the used object functions.
	if !used-object-functions is-empty
		stream write: "\t"
		done-one = false
		for name in used-object-functions keys
			if done-one
				stream write: " "
			else
				done-one = true
			stream write-all: ("UsingMethod_(", (mangle-name: name), ")")
		stream write-line
	
	# Emit the extern declarations.
	if !extern-declarations is-empty
		for declaration in extern-declarations
			stream write: "\t"
			stream write-line: declaration
	
	# Emit the used (non-object fields).
	if !used-fields is-empty
		stream write: "\textern obj_ "
		done-one = false
		for field in used-fields keys
			on-package = used-fields at: field

			if done-one
				stream write: ", "
			else
				done-one = true
			stream write-all: ((mangle-name: field name), "__", on-package c-name)
		stream write-line: ";"
	
	# Emit the used classes.
	for used-class in used-classes values
		stream write: "\textern class_spec_ "
		stream write: used-class c-name
		stream write-line: ";"
	
	stream write-line

	# Emit the body of the code.
	stream write: code string

	stream write-line: "\treturn NULL;"
	stream write-line: "}"



