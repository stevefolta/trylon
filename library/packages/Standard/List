trylon-class List

fields first-cell last-cell


fn create
	first-cell = nil
	last-cell = nil

fn append: object
	cell := Cell new: object
	if last-cell != nil
		last-cell next = cell
	last-cell = cell
	if first-cell == nil
		first-cell = cell

fn prepend: object
	cell := Cell new: object
	cell next = first-cell
	first-cell = cell

fn iterator -> Standard Iterator
	return Iterator new: first-cell

fn is-empty
	return (first-cell == nil)

fn count
	num-items := 0
	cell := first-cell
	while cell
		num-items += 1
		cell = cell next
	return num-items

fn first-item
	if first-cell == nil
		return nil
	return first-cell object

fn last-item
	if last-cell == nil
		return nil
	return last-cell object

fn head
	return first-item

fn tail
	tail-list := List new
	if first-cell
		tail-list first-cell = first-cell next
	else
		tail-list first-cell = nil
	tail-list last-cell = last-cell
	return tail-list


fn pop-front
	if first-cell == nil
		return nil
	
	object := first-cell object
	
	if first-cell == last-cell
		first-cell = nil
		last-cell = nil
	else
		first-cell = first-cell next
	
	return object


fn remove: object
	cell := first-cell
	prev-cell := nil
	while cell
		if cell object == object
			# Unlink the cell.
			if prev-cell
				prev-cell next = cell next
			else
				first-cell = cell next
			# Is it the last cell?
			if cell == last-cell
				last-cell = prev-cell
			break
		
		prev-cell = cell
		cell = cell next


fn contains: object
	cell := first-cell
	while cell
		if cell object same-as: object
			return true
		cell = cell next
	return false


fn insert: new-object before: before-object
	cell := first-cell
	prev-cell := nil
	while cell
		if cell object same-as: before-object
			new-cell := Cell new: new-object
			new-cell next = cell
			if prev-cell
				prev-cell next = new-cell
			else
				first-cell = new-cell
			return
		prev-cell = cell
		cell = cell next


fn replace: old-object with: new-object
	cell := first-cell
	while cell
		if cell object same-as: old-object
			cell object = new-object
			return
		cell = cell next


fn clear
	first-cell = nil
	last-cell = nil


iff lambdas-implemented
	fn for-each: block
		cell = first-cell
		while cell
			block do-with: cell object
			cell = cell next



class Cell
	fields object next
	fn create: object
		this object = object
		next = nil


class Iterator
	superclass Standard Iterator
	field cell
	fn create: cell
		this cell = cell
	fn is-done -> Bool
		return cell == nil
	fn current-item
		return cell object
	fn go-forward
		cell = cell next
